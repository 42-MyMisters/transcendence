{"ast":null,"code":"let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = get => get(config);\n    config.write = (get, set, arg) => set(config, typeof arg === \"function\" ? arg(get(config)) : arg);\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nconst hasInitialValue = atom => \"init\" in atom;\nconst isActuallyWritableAtom = atom => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {}).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isEqualAtomValue = (a, b) => \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = a => \"v\" in a && a.v instanceof Promise;\nconst returnAtomValue = atomState => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */new WeakMap();\n  const mountedMap = /* @__PURE__ */new WeakMap();\n  const pendingMap = /* @__PURE__ */new Map();\n  let storeListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    storeListeners = /* @__PURE__ */new Set();\n    mountedAtoms = /* @__PURE__ */new Set();\n  }\n  const getAtomState = atom => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      cancelPromise(prevAtomState.v, next);\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies) => {\n    const dependencies = /* @__PURE__ */new Map();\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && a === atom) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (valueOrPromise instanceof Promise) {\n      let continuePromise;\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(v => {\n          if (!settled) {\n            settled = true;\n            const prevAtomState = getAtomState(atom);\n            const nextAtomState = setAtomValue(atom, promise, nextDependencies);\n            resolvePromise(promise, v);\n            resolve(v);\n            if ((prevAtomState == null ? void 0 : prevAtomState.d) !== nextAtomState.d) {\n              mountDependencies(atom, nextAtomState, prevAtomState == null ? void 0 : prevAtomState.d);\n            }\n          }\n        }, e => {\n          if (!settled) {\n            settled = true;\n            const prevAtomState = getAtomState(atom);\n            const nextAtomState = setAtomValue(atom, promise, nextDependencies);\n            rejectPromise(promise, e);\n            reject(e);\n            if ((prevAtomState == null ? void 0 : prevAtomState.d) !== nextAtomState.d) {\n              mountDependencies(atom, nextAtomState, prevAtomState == null ? void 0 : prevAtomState.d);\n            }\n          }\n        });\n        continuePromise = next => {\n          if (!settled) {\n            settled = true;\n            next.then(v => resolvePromise(promise, v), e => rejectPromise(promise, e));\n            resolve(next);\n          }\n        };\n      });\n      promise.status = \"pending\";\n      registerCancelPromise(promise, next => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = atom => {\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom && !mountedMap.has(a)) {\n          readAtomState(a);\n        }\n      });\n      if (Array.from(atomState.d).every(_ref => {\n        let [a, s] = _ref;\n        return a === atom || getAtomState(a) === s;\n      })) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */new Map();\n    let isSync = true;\n    const getter = a => {\n      if (a === atom) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = function () {\n            if ((import.meta.env && import.meta.env.MODE) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(atom, valueOrPromise, nextDependencies, () => controller == null ? void 0 : controller.abort());\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = atom => returnAtomValue(readAtomState(atom));\n  const addAtom = atom => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = atom => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = atom => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach(dependent => {\n      if (dependent !== atom) {\n        const prevAtomState = getAtomState(dependent);\n        const nextAtomState = readAtomState(dependent);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(dependent);\n        }\n      }\n    });\n  };\n  const writeAtomState = function (atom) {\n    let isSync = true;\n    const getter = a => returnAtomValue(readAtomState(a));\n    const setter = function (a) {\n      let r;\n      for (var _len3 = arguments.length, args2 = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args2[_key3 - 1] = arguments[_key3];\n      }\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        flushPending();\n      }\n      return r;\n    };\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = function (atom) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    const result = writeAtomState(atom, ...args);\n    flushPending();\n    return result;\n  };\n  const mountAtom = (atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    readAtomState(atom).d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    readAtomState(atom);\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const onUnmount = atom.onMount(function () {\n        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n        return writeAtom(atom, ...args);\n      });\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = atom => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach(a => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = () => {\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(_ref2 => {\n        let [atom, prevAtomState] = _ref2;\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          const mounted = mountedMap.get(atom);\n          if (mounted && !(\n          // TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          prevAtomState && !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach(listener => listener());\n          }\n        } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      storeListeners.forEach(l => l(\"state\"));\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      storeListeners.forEach(l => l(\"sub\"));\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        storeListeners.forEach(l => l(\"unsub\"));\n      }\n    };\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: l => {\n        storeListeners.add(l);\n        return () => {\n          storeListeners.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: a => atomStateMap.get(a),\n      dev_get_mounted: a => mountedMap.get(a),\n      dev_restore_atoms: values => {\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        flushPending();\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\nexport { atom, createStore, getDefaultStore };","map":{"version":3,"names":["keyCount","atom","read","write","key","config","toString","init","get","set","arg","hasInitialValue","isActuallyWritableAtom","cancelPromiseMap","WeakMap","registerCancelPromise","promise","cancel","catch","finally","delete","cancelPromise","next","resolvePromise","value","status","rejectPromise","e","reason","isEqualAtomValue","a","b","Object","is","v","isEqualAtomError","hasPromiseAtomValue","Promise","returnAtomValue","atomState","createStore","atomStateMap","mountedMap","pendingMap","Map","storeListeners","mountedAtoms","import","meta","env","MODE","Set","getAtomState","setAtomState","freeze","prevAtomState","has","resolve","reject","updateDependencies","nextAtomState","nextDependencies","dependencies","changed","forEach","aState","d","console","warn","size","setAtomValue","setAtomValueOrPromise","valueOrPromise","abortPromise","continuePromise","settled","then","mountDependencies","setAtomError","error","readAtomState","_","Array","from","every","_ref","s","isSync","getter","aState2","Error","controller","setSelf","options","signal","AbortController","_len","arguments","length","args","_key","writeAtom","abort","readAtom","addAtom","mounted","mountAtom","canUnmountAtom","l","t","delAtom","unmountAtom","recomputeDependents","dependent","writeAtomState","setter","r","_len3","args2","_key3","flushPending","_len2","_key2","result","_len4","_key4","initialDependent","add","aMounted","onMount","onUnmount","_len5","_key5","u","_a","prevDependencies","depSet","keys","pending","clear","_ref2","listener","subscribeAtom","listeners","sub","dev_subscribe_store","dev_get_mounted_atoms","values","dev_get_atom_state","dev_get_mounted","dev_restore_atoms","defaultStore","getDefaultStore"],"sources":["/data/front/node_modules/jotai/esm/vanilla.mjs"],"sourcesContent":["let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = (get) => get(config);\n    config.write = (get, set, arg) => set(\n      config,\n      typeof arg === \"function\" ? arg(get(config)) : arg\n    );\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isEqualAtomValue = (a, b) => \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => \"v\" in a && a.v instanceof Promise;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let storeListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    storeListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      cancelPromise(prevAtomState.v, next);\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies) => {\n    const dependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && a === atom) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (valueOrPromise instanceof Promise) {\n      let continuePromise;\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(\n          (v) => {\n            if (!settled) {\n              settled = true;\n              const prevAtomState = getAtomState(atom);\n              const nextAtomState = setAtomValue(\n                atom,\n                promise,\n                nextDependencies\n              );\n              resolvePromise(promise, v);\n              resolve(v);\n              if ((prevAtomState == null ? void 0 : prevAtomState.d) !== nextAtomState.d) {\n                mountDependencies(atom, nextAtomState, prevAtomState == null ? void 0 : prevAtomState.d);\n              }\n            }\n          },\n          (e) => {\n            if (!settled) {\n              settled = true;\n              const prevAtomState = getAtomState(atom);\n              const nextAtomState = setAtomValue(\n                atom,\n                promise,\n                nextDependencies\n              );\n              rejectPromise(promise, e);\n              reject(e);\n              if ((prevAtomState == null ? void 0 : prevAtomState.d) !== nextAtomState.d) {\n                mountDependencies(atom, nextAtomState, prevAtomState == null ? void 0 : prevAtomState.d);\n              }\n            }\n          }\n        );\n        continuePromise = (next) => {\n          if (!settled) {\n            settled = true;\n            next.then(\n              (v) => resolvePromise(promise, v),\n              (e) => rejectPromise(promise, e)\n            );\n            resolve(next);\n          }\n        };\n      });\n      promise.status = \"pending\";\n      registerCancelPromise(promise, (next) => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom) => {\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom && !mountedMap.has(a)) {\n          readAtomState(a);\n        }\n      });\n      if (Array.from(atomState.d).every(\n        ([a, s]) => a === atom || getAtomState(a) === s\n      )) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */ new Map();\n    let isSync = true;\n    const getter = (a) => {\n      if (a === atom) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env && import.meta.env.MODE) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(\n        atom,\n        valueOrPromise,\n        nextDependencies,\n        () => controller == null ? void 0 : controller.abort()\n      );\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        const prevAtomState = getAtomState(dependent);\n        const nextAtomState = readAtomState(dependent);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(dependent);\n        }\n      }\n    });\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        flushPending();\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    flushPending();\n    return result;\n  };\n  const mountAtom = (atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    readAtomState(atom).d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    readAtomState(atom);\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const onUnmount = atom.onMount((...args) => writeAtom(atom, ...args));\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = () => {\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          const mounted = mountedMap.get(atom);\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (prevAtomState && !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n          }\n        } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      storeListeners.forEach((l) => l(\"state\"));\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      storeListeners.forEach((l) => l(\"sub\"));\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        storeListeners.forEach((l) => l(\"unsub\"));\n      }\n    };\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l) => {\n        storeListeners.add(l);\n        return () => {\n          storeListeners.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        flushPending();\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}