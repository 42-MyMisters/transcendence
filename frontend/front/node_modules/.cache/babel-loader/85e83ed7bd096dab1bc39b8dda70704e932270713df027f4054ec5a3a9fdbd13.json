{"ast":null,"code":"let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = get => get(config);\n    config.write = (get, set, arg) => set(config, typeof arg === \"function\" ? arg(get(config)) : arg);\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nconst hasInitialValue = atom => \"init\" in atom;\nconst isActuallyWritableAtom = atom => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {}).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isEqualAtomValue = (a, b) => \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = a => \"v\" in a && a.v instanceof Promise;\nconst returnAtomValue = atomState => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */new WeakMap();\n  const mountedMap = /* @__PURE__ */new WeakMap();\n  const pendingMap = /* @__PURE__ */new Map();\n  let stateListeners;\n  let storeListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */new Set();\n    storeListeners = /* @__PURE__ */new Set();\n    mountedAtoms = /* @__PURE__ */new Set();\n  }\n  const getAtomState = atom => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      cancelPromise(prevAtomState.v, next);\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, depSet) => {\n    const dependencies = /* @__PURE__ */new Map();\n    let changed = false;\n    depSet.forEach(a => {\n      const aState = a === atom ? nextAtomState : getAtomState(a);\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */new Map(),\n      v: value\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomError = (atom, error, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */new Map(),\n      e: error\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = atom => {\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom && !mountedMap.has(a)) {\n          readAtomState(a);\n        }\n      });\n      if (Array.from(atomState.d).every(_ref => {\n        let [a, s] = _ref;\n        return a === atom || getAtomState(a) === s;\n      })) {\n        return atomState;\n      }\n    }\n    const depSet = /* @__PURE__ */new Set();\n    let isSync = true;\n    const getter = a => {\n      depSet.add(a);\n      if (a === atom) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = function () {\n            if ((import.meta.env && import.meta.env.MODE) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const value = atom.read(getter, options);\n      if (value instanceof Promise) {\n        let continuePromise;\n        const promise = new Promise((resolve, reject) => {\n          let settled = false;\n          value.then(v => {\n            if (!settled) {\n              settled = true;\n              setAtomValue(atom, promise, depSet);\n              resolvePromise(promise, v);\n              resolve(v);\n            }\n          }, e => {\n            if (!settled) {\n              settled = true;\n              setAtomValue(atom, promise, depSet);\n              rejectPromise(promise, e);\n              reject(e);\n            }\n          });\n          continuePromise = next => {\n            if (!settled) {\n              settled = true;\n              next.then(v => resolvePromise(promise, v), e => rejectPromise(promise, e));\n              resolve(next);\n            }\n          };\n        });\n        promise.status = \"pending\";\n        registerCancelPromise(promise, next => {\n          if (next) {\n            continuePromise(next);\n          }\n          controller == null ? void 0 : controller.abort();\n        });\n        return setAtomValue(atom, promise, depSet);\n      }\n      return setAtomValue(atom, value, depSet);\n    } catch (error) {\n      return setAtomError(atom, error, depSet);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = atom => returnAtomValue(readAtomState(atom));\n  const addAtom = atom => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = atom => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = atom => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach(dependent => {\n      if (dependent !== atom) {\n        const prevAtomState = getAtomState(dependent);\n        const nextAtomState = readAtomState(dependent);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(dependent);\n        }\n      }\n    });\n  };\n  const writeAtomState = function (atom) {\n    let isSync = true;\n    const getter = a => returnAtomValue(readAtomState(a));\n    const setter = function (a) {\n      let r;\n      for (var _len3 = arguments.length, args2 = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args2[_key3 - 1] = arguments[_key3];\n      }\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValue(a, args2[0]);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        flushPending();\n      }\n      return r;\n    };\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = function (atom) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    const result = writeAtomState(atom, ...args);\n    flushPending();\n    return result;\n  };\n  const mountAtom = (atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    readAtomState(atom).d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    readAtomState(atom);\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const onUnmount = atom.onMount(function () {\n        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n        return writeAtom(atom, ...args);\n      });\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = atom => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach(a => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = () => {\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(_ref2 => {\n        let [atom, prevAtomState] = _ref2;\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          const mounted = mountedMap.get(atom);\n          if (mounted && !(\n          // TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          prevAtomState && !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach(listener => listener());\n          }\n        } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach(l => l());\n      storeListeners.forEach(l => l(\"state\"));\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      storeListeners.forEach(l => l(\"sub\"));\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        storeListeners.forEach(l => l(\"unsub\"));\n      }\n    };\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_state: l => {\n        console.warn(\"[DEPRECATED] dev_subscribe_state is deprecated and will be removed in the next minor version. use dev_subscribe_store instead.\");\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      dev_subscribe_store: l => {\n        storeListeners.add(l);\n        return () => {\n          storeListeners.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: a => atomStateMap.get(a),\n      dev_get_mounted: a => mountedMap.get(a),\n      dev_restore_atoms: values => {\n        for (const [atom, value] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValue(atom, value);\n            recomputeDependents(atom);\n          }\n        }\n        flushPending();\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\nexport { atom, createStore, getDefaultStore };","map":{"version":3,"names":["keyCount","atom","read","write","key","config","toString","init","get","set","arg","hasInitialValue","isActuallyWritableAtom","cancelPromiseMap","WeakMap","registerCancelPromise","promise","cancel","catch","finally","delete","cancelPromise","next","resolvePromise","value","status","rejectPromise","e","reason","isEqualAtomValue","a","b","Object","is","v","isEqualAtomError","hasPromiseAtomValue","Promise","returnAtomValue","atomState","createStore","atomStateMap","mountedMap","pendingMap","Map","stateListeners","storeListeners","mountedAtoms","import","meta","env","MODE","Set","getAtomState","setAtomState","freeze","prevAtomState","has","resolve","reject","updateDependencies","nextAtomState","depSet","dependencies","changed","forEach","aState","d","console","warn","size","setAtomValue","setAtomError","error","readAtomState","_","Array","from","every","_ref","s","isSync","getter","add","aState2","Error","controller","setSelf","options","signal","AbortController","_len","arguments","length","args","_key","writeAtom","continuePromise","settled","then","abort","readAtom","addAtom","mounted","mountAtom","canUnmountAtom","l","t","delAtom","unmountAtom","recomputeDependents","dependent","writeAtomState","setter","r","_len3","args2","_key3","flushPending","_len2","_key2","result","_len4","_key4","initialDependent","aMounted","onMount","onUnmount","_len5","_key5","u","_a","mountDependencies","prevDependencies","keys","pending","clear","_ref2","listener","subscribeAtom","listeners","sub","dev_subscribe_state","dev_subscribe_store","dev_get_mounted_atoms","values","dev_get_atom_state","dev_get_mounted","dev_restore_atoms","defaultStore","getDefaultStore"],"sources":["/data/front/node_modules/jotai/esm/vanilla.mjs"],"sourcesContent":["let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = (get) => get(config);\n    config.write = (get, set, arg) => set(\n      config,\n      typeof arg === \"function\" ? arg(get(config)) : arg\n    );\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isEqualAtomValue = (a, b) => \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => \"v\" in a && a.v instanceof Promise;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let storeListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    storeListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      cancelPromise(prevAtomState.v, next);\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, depSet) => {\n    const dependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    depSet.forEach((a) => {\n      const aState = a === atom ? nextAtomState : getAtomState(a);\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomError = (atom, error, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom) => {\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom && !mountedMap.has(a)) {\n          readAtomState(a);\n        }\n      });\n      if (Array.from(atomState.d).every(\n        ([a, s]) => a === atom || getAtomState(a) === s\n      )) {\n        return atomState;\n      }\n    }\n    const depSet = /* @__PURE__ */ new Set();\n    let isSync = true;\n    const getter = (a) => {\n      depSet.add(a);\n      if (a === atom) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env && import.meta.env.MODE) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const value = atom.read(getter, options);\n      if (value instanceof Promise) {\n        let continuePromise;\n        const promise = new Promise((resolve, reject) => {\n          let settled = false;\n          value.then(\n            (v) => {\n              if (!settled) {\n                settled = true;\n                setAtomValue(atom, promise, depSet);\n                resolvePromise(promise, v);\n                resolve(v);\n              }\n            },\n            (e) => {\n              if (!settled) {\n                settled = true;\n                setAtomValue(atom, promise, depSet);\n                rejectPromise(promise, e);\n                reject(e);\n              }\n            }\n          );\n          continuePromise = (next) => {\n            if (!settled) {\n              settled = true;\n              next.then(\n                (v) => resolvePromise(promise, v),\n                (e) => rejectPromise(promise, e)\n              );\n              resolve(next);\n            }\n          };\n        });\n        promise.status = \"pending\";\n        registerCancelPromise(promise, (next) => {\n          if (next) {\n            continuePromise(next);\n          }\n          controller == null ? void 0 : controller.abort();\n        });\n        return setAtomValue(atom, promise, depSet);\n      }\n      return setAtomValue(atom, value, depSet);\n    } catch (error) {\n      return setAtomError(atom, error, depSet);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        const prevAtomState = getAtomState(dependent);\n        const nextAtomState = readAtomState(dependent);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(dependent);\n        }\n      }\n    });\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValue(a, args2[0]);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        flushPending();\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    flushPending();\n    return result;\n  };\n  const mountAtom = (atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    readAtomState(atom).d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    readAtomState(atom);\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const onUnmount = atom.onMount((...args) => writeAtom(atom, ...args));\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = () => {\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          const mounted = mountedMap.get(atom);\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (prevAtomState && !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n          }\n        } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n      storeListeners.forEach((l) => l(\"state\"));\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      storeListeners.forEach((l) => l(\"sub\"));\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        storeListeners.forEach((l) => l(\"unsub\"));\n      }\n    };\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_state: (l) => {\n        console.warn(\n          \"[DEPRECATED] dev_subscribe_state is deprecated and will be removed in the next minor version. use dev_subscribe_store instead.\"\n        );\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      dev_subscribe_store: (l) => {\n        storeListeners.add(l);\n        return () => {\n          storeListeners.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom, value] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValue(atom, value);\n            recomputeDependents(atom);\n          }\n        }\n        flushPending();\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n"],"mappings":"AAAA,IAAIA,QAAQ,GAAG,CAAC;AAChB,SAASC,IAAIA,CAACC,IAAI,EAAEC,KAAK,EAAE;EACzB,MAAMC,GAAG,GAAI,OAAM,EAAEJ,QAAS,EAAC;EAC/B,MAAMK,MAAM,GAAG;IACbC,QAAQ,EAAEA,CAAA,KAAMF;EAClB,CAAC;EACD,IAAI,OAAOF,IAAI,KAAK,UAAU,EAAE;IAC9BG,MAAM,CAACH,IAAI,GAAGA,IAAI;EACpB,CAAC,MAAM;IACLG,MAAM,CAACE,IAAI,GAAGL,IAAI;IAClBG,MAAM,CAACH,IAAI,GAAIM,GAAG,IAAKA,GAAG,CAACH,MAAM,CAAC;IAClCA,MAAM,CAACF,KAAK,GAAG,CAACK,GAAG,EAAEC,GAAG,EAAEC,GAAG,KAAKD,GAAG,CACnCJ,MAAM,EACN,OAAOK,GAAG,KAAK,UAAU,GAAGA,GAAG,CAACF,GAAG,CAACH,MAAM,CAAC,CAAC,GAAGK,GAAG,CACnD;EACH;EACA,IAAIP,KAAK,EAAE;IACTE,MAAM,CAACF,KAAK,GAAGA,KAAK;EACtB;EACA,OAAOE,MAAM;AACf;AAEA,MAAMM,eAAe,GAAIV,IAAI,IAAK,MAAM,IAAIA,IAAI;AAChD,MAAMW,sBAAsB,GAAIX,IAAI,IAAK,CAAC,CAACA,IAAI,CAACE,KAAK;AACrD,MAAMU,gBAAgB,GAAG,eAAgB,IAAIC,OAAO,EAAE;AACtD,MAAMC,qBAAqB,GAAGA,CAACC,OAAO,EAAEC,MAAM,KAAK;EACjDJ,gBAAgB,CAACJ,GAAG,CAACO,OAAO,EAAEC,MAAM,CAAC;EACrCD,OAAO,CAACE,KAAK,CAAC,MAAM,CACpB,CAAC,CAAC,CAACC,OAAO,CAAC,MAAMN,gBAAgB,CAACO,MAAM,CAACJ,OAAO,CAAC,CAAC;AACpD,CAAC;AACD,MAAMK,aAAa,GAAGA,CAACL,OAAO,EAAEM,IAAI,KAAK;EACvC,MAAML,MAAM,GAAGJ,gBAAgB,CAACL,GAAG,CAACQ,OAAO,CAAC;EAC5C,IAAIC,MAAM,EAAE;IACVJ,gBAAgB,CAACO,MAAM,CAACJ,OAAO,CAAC;IAChCC,MAAM,CAACK,IAAI,CAAC;EACd;AACF,CAAC;AACD,MAAMC,cAAc,GAAGA,CAACP,OAAO,EAAEQ,KAAK,KAAK;EACzCR,OAAO,CAACS,MAAM,GAAG,WAAW;EAC5BT,OAAO,CAACQ,KAAK,GAAGA,KAAK;AACvB,CAAC;AACD,MAAME,aAAa,GAAGA,CAACV,OAAO,EAAEW,CAAC,KAAK;EACpCX,OAAO,CAACS,MAAM,GAAG,UAAU;EAC3BT,OAAO,CAACY,MAAM,GAAGD,CAAC;AACpB,CAAC;AACD,MAAME,gBAAgB,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAK,GAAG,IAAID,CAAC,IAAI,GAAG,IAAIC,CAAC,IAAIC,MAAM,CAACC,EAAE,CAACH,CAAC,CAACI,CAAC,EAAEH,CAAC,CAACG,CAAC,CAAC;AAC9E,MAAMC,gBAAgB,GAAGA,CAACL,CAAC,EAAEC,CAAC,KAAK,GAAG,IAAID,CAAC,IAAI,GAAG,IAAIC,CAAC,IAAIC,MAAM,CAACC,EAAE,CAACH,CAAC,CAACH,CAAC,EAAEI,CAAC,CAACJ,CAAC,CAAC;AAC9E,MAAMS,mBAAmB,GAAIN,CAAC,IAAK,GAAG,IAAIA,CAAC,IAAIA,CAAC,CAACI,CAAC,YAAYG,OAAO;AACrE,MAAMC,eAAe,GAAIC,SAAS,IAAK;EACrC,IAAI,GAAG,IAAIA,SAAS,EAAE;IACpB,MAAMA,SAAS,CAACZ,CAAC;EACnB;EACA,OAAOY,SAAS,CAACL,CAAC;AACpB,CAAC;AACD,MAAMM,WAAW,GAAGA,CAAA,KAAM;EACxB,MAAMC,YAAY,GAAG,eAAgB,IAAI3B,OAAO,EAAE;EAClD,MAAM4B,UAAU,GAAG,eAAgB,IAAI5B,OAAO,EAAE;EAChD,MAAM6B,UAAU,GAAG,eAAgB,IAAIC,GAAG,EAAE;EAC5C,IAAIC,cAAc;EAClB,IAAIC,cAAc;EAClB,IAAIC,YAAY;EAChB,IAAI,CAACC,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;IAC9DN,cAAc,GAAG,eAAgB,IAAIO,GAAG,EAAE;IAC1CN,cAAc,GAAG,eAAgB,IAAIM,GAAG,EAAE;IAC1CL,YAAY,GAAG,eAAgB,IAAIK,GAAG,EAAE;EAC1C;EACA,MAAMC,YAAY,GAAIpD,IAAI,IAAKwC,YAAY,CAACjC,GAAG,CAACP,IAAI,CAAC;EACrD,MAAMqD,YAAY,GAAGA,CAACrD,IAAI,EAAEsC,SAAS,KAAK;IACxC,IAAI,CAACS,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;MAC9DnB,MAAM,CAACuB,MAAM,CAAChB,SAAS,CAAC;IAC1B;IACA,MAAMiB,aAAa,GAAGf,YAAY,CAACjC,GAAG,CAACP,IAAI,CAAC;IAC5CwC,YAAY,CAAChC,GAAG,CAACR,IAAI,EAAEsC,SAAS,CAAC;IACjC,IAAI,CAACI,UAAU,CAACc,GAAG,CAACxD,IAAI,CAAC,EAAE;MACzB0C,UAAU,CAAClC,GAAG,CAACR,IAAI,EAAEuD,aAAa,CAAC;IACrC;IACA,IAAIA,aAAa,IAAIpB,mBAAmB,CAACoB,aAAa,CAAC,EAAE;MACvD,MAAMlC,IAAI,GAAG,GAAG,IAAIiB,SAAS,GAAGA,SAAS,CAACL,CAAC,YAAYG,OAAO,GAAGE,SAAS,CAACL,CAAC,GAAGG,OAAO,CAACqB,OAAO,CAACnB,SAAS,CAACL,CAAC,CAAC,GAAGG,OAAO,CAACsB,MAAM,CAACpB,SAAS,CAACZ,CAAC,CAAC;MACzIN,aAAa,CAACmC,aAAa,CAACtB,CAAC,EAAEZ,IAAI,CAAC;IACtC;EACF,CAAC;EACD,MAAMsC,kBAAkB,GAAGA,CAAC3D,IAAI,EAAE4D,aAAa,EAAEC,MAAM,KAAK;IAC1D,MAAMC,YAAY,GAAG,eAAgB,IAAInB,GAAG,EAAE;IAC9C,IAAIoB,OAAO,GAAG,KAAK;IACnBF,MAAM,CAACG,OAAO,CAAEnC,CAAC,IAAK;MACpB,MAAMoC,MAAM,GAAGpC,CAAC,KAAK7B,IAAI,GAAG4D,aAAa,GAAGR,YAAY,CAACvB,CAAC,CAAC;MAC3D,IAAIoC,MAAM,EAAE;QACVH,YAAY,CAACtD,GAAG,CAACqB,CAAC,EAAEoC,MAAM,CAAC;QAC3B,IAAIL,aAAa,CAACM,CAAC,CAAC3D,GAAG,CAACsB,CAAC,CAAC,KAAKoC,MAAM,EAAE;UACrCF,OAAO,GAAG,IAAI;QAChB;MACF,CAAC,MAAM,IAAI,CAAChB,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;QACrEiB,OAAO,CAACC,IAAI,CAAC,4BAA4B,CAAC;MAC5C;IACF,CAAC,CAAC;IACF,IAAIL,OAAO,IAAIH,aAAa,CAACM,CAAC,CAACG,IAAI,KAAKP,YAAY,CAACO,IAAI,EAAE;MACzDT,aAAa,CAACM,CAAC,GAAGJ,YAAY;IAChC;EACF,CAAC;EACD,MAAMQ,YAAY,GAAGA,CAACtE,IAAI,EAAEuB,KAAK,EAAEsC,MAAM,KAAK;IAC5C,MAAMN,aAAa,GAAGH,YAAY,CAACpD,IAAI,CAAC;IACxC,MAAM4D,aAAa,GAAG;MACpBM,CAAC,EAAE,CAACX,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,aAAa,CAACW,CAAC,KAAK,eAAgB,IAAIvB,GAAG,EAAE;MAClFV,CAAC,EAAEV;IACL,CAAC;IACD,IAAIsC,MAAM,EAAE;MACVF,kBAAkB,CAAC3D,IAAI,EAAE4D,aAAa,EAAEC,MAAM,CAAC;IACjD;IACA,IAAIN,aAAa,IAAI3B,gBAAgB,CAAC2B,aAAa,EAAEK,aAAa,CAAC,IAAIL,aAAa,CAACW,CAAC,KAAKN,aAAa,CAACM,CAAC,EAAE;MAC1G,OAAOX,aAAa;IACtB;IACAF,YAAY,CAACrD,IAAI,EAAE4D,aAAa,CAAC;IACjC,OAAOA,aAAa;EACtB,CAAC;EACD,MAAMW,YAAY,GAAGA,CAACvE,IAAI,EAAEwE,KAAK,EAAEX,MAAM,KAAK;IAC5C,MAAMN,aAAa,GAAGH,YAAY,CAACpD,IAAI,CAAC;IACxC,MAAM4D,aAAa,GAAG;MACpBM,CAAC,EAAE,CAACX,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,aAAa,CAACW,CAAC,KAAK,eAAgB,IAAIvB,GAAG,EAAE;MAClFjB,CAAC,EAAE8C;IACL,CAAC;IACD,IAAIX,MAAM,EAAE;MACVF,kBAAkB,CAAC3D,IAAI,EAAE4D,aAAa,EAAEC,MAAM,CAAC;IACjD;IACA,IAAIN,aAAa,IAAIrB,gBAAgB,CAACqB,aAAa,EAAEK,aAAa,CAAC,IAAIL,aAAa,CAACW,CAAC,KAAKN,aAAa,CAACM,CAAC,EAAE;MAC1G,OAAOX,aAAa;IACtB;IACAF,YAAY,CAACrD,IAAI,EAAE4D,aAAa,CAAC;IACjC,OAAOA,aAAa;EACtB,CAAC;EACD,MAAMa,aAAa,GAAIzE,IAAI,IAAK;IAC9B,MAAMsC,SAAS,GAAGc,YAAY,CAACpD,IAAI,CAAC;IACpC,IAAIsC,SAAS,EAAE;MACbA,SAAS,CAAC4B,CAAC,CAACF,OAAO,CAAC,CAACU,CAAC,EAAE7C,CAAC,KAAK;QAC5B,IAAIA,CAAC,KAAK7B,IAAI,IAAI,CAACyC,UAAU,CAACe,GAAG,CAAC3B,CAAC,CAAC,EAAE;UACpC4C,aAAa,CAAC5C,CAAC,CAAC;QAClB;MACF,CAAC,CAAC;MACF,IAAI8C,KAAK,CAACC,IAAI,CAACtC,SAAS,CAAC4B,CAAC,CAAC,CAACW,KAAK,CAC/BC,IAAA;QAAA,IAAC,CAACjD,CAAC,EAAEkD,CAAC,CAAC,GAAAD,IAAA;QAAA,OAAKjD,CAAC,KAAK7B,IAAI,IAAIoD,YAAY,CAACvB,CAAC,CAAC,KAAKkD,CAAC;MAAA,EAChD,EAAE;QACD,OAAOzC,SAAS;MAClB;IACF;IACA,MAAMuB,MAAM,GAAG,eAAgB,IAAIV,GAAG,EAAE;IACxC,IAAI6B,MAAM,GAAG,IAAI;IACjB,MAAMC,MAAM,GAAIpD,CAAC,IAAK;MACpBgC,MAAM,CAACqB,GAAG,CAACrD,CAAC,CAAC;MACb,IAAIA,CAAC,KAAK7B,IAAI,EAAE;QACd,MAAMmF,OAAO,GAAG/B,YAAY,CAACvB,CAAC,CAAC;QAC/B,IAAIsD,OAAO,EAAE;UACX,OAAO9C,eAAe,CAAC8C,OAAO,CAAC;QACjC;QACA,IAAIzE,eAAe,CAACmB,CAAC,CAAC,EAAE;UACtB,OAAOA,CAAC,CAACvB,IAAI;QACf;QACA,MAAM,IAAI8E,KAAK,CAAC,cAAc,CAAC;MACjC;MACA,MAAMnB,MAAM,GAAGQ,aAAa,CAAC5C,CAAC,CAAC;MAC/B,OAAOQ,eAAe,CAAC4B,MAAM,CAAC;IAChC,CAAC;IACD,IAAIoB,UAAU;IACd,IAAIC,OAAO;IACX,MAAMC,OAAO,GAAG;MACd,IAAIC,MAAMA,CAAA,EAAG;QACX,IAAI,CAACH,UAAU,EAAE;UACfA,UAAU,GAAG,IAAII,eAAe,EAAE;QACpC;QACA,OAAOJ,UAAU,CAACG,MAAM;MAC1B,CAAC;MACD,IAAIF,OAAOA,CAAA,EAAG;QACZ,IAAI,CAACvC,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,IAAI,CAACvC,sBAAsB,CAACX,IAAI,CAAC,EAAE;UAC/FmE,OAAO,CAACC,IAAI,CAAC,qDAAqD,CAAC;QACrE;QACA,IAAI,CAACkB,OAAO,IAAI3E,sBAAsB,CAACX,IAAI,CAAC,EAAE;UAC5CsF,OAAO,GAAG,SAAAA,CAAA,EAAa;YACrB,IAAI,CAACvC,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,IAAI8B,MAAM,EAAE;cACxEb,OAAO,CAACC,IAAI,CAAC,2CAA2C,CAAC;YAC3D;YACA,IAAI,CAACY,MAAM,EAAE;cAAA,SAAAU,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAJDC,IAAI,OAAAlB,KAAA,CAAAe,IAAA,GAAAI,IAAA,MAAAA,IAAA,GAAAJ,IAAA,EAAAI,IAAA;gBAAJD,IAAI,CAAAC,IAAA,IAAAH,SAAA,CAAAG,IAAA;cAAA;cAKd,OAAOC,SAAS,CAAC/F,IAAI,EAAE,GAAG6F,IAAI,CAAC;YACjC;UACF,CAAC;QACH;QACA,OAAOP,OAAO;MAChB;IACF,CAAC;IACD,IAAI;MACF,MAAM/D,KAAK,GAAGvB,IAAI,CAACC,IAAI,CAACgF,MAAM,EAAEM,OAAO,CAAC;MACxC,IAAIhE,KAAK,YAAYa,OAAO,EAAE;QAC5B,IAAI4D,eAAe;QACnB,MAAMjF,OAAO,GAAG,IAAIqB,OAAO,CAAC,CAACqB,OAAO,EAAEC,MAAM,KAAK;UAC/C,IAAIuC,OAAO,GAAG,KAAK;UACnB1E,KAAK,CAAC2E,IAAI,CACPjE,CAAC,IAAK;YACL,IAAI,CAACgE,OAAO,EAAE;cACZA,OAAO,GAAG,IAAI;cACd3B,YAAY,CAACtE,IAAI,EAAEe,OAAO,EAAE8C,MAAM,CAAC;cACnCvC,cAAc,CAACP,OAAO,EAAEkB,CAAC,CAAC;cAC1BwB,OAAO,CAACxB,CAAC,CAAC;YACZ;UACF,CAAC,EACAP,CAAC,IAAK;YACL,IAAI,CAACuE,OAAO,EAAE;cACZA,OAAO,GAAG,IAAI;cACd3B,YAAY,CAACtE,IAAI,EAAEe,OAAO,EAAE8C,MAAM,CAAC;cACnCpC,aAAa,CAACV,OAAO,EAAEW,CAAC,CAAC;cACzBgC,MAAM,CAAChC,CAAC,CAAC;YACX;UACF,CAAC,CACF;UACDsE,eAAe,GAAI3E,IAAI,IAAK;YAC1B,IAAI,CAAC4E,OAAO,EAAE;cACZA,OAAO,GAAG,IAAI;cACd5E,IAAI,CAAC6E,IAAI,CACNjE,CAAC,IAAKX,cAAc,CAACP,OAAO,EAAEkB,CAAC,CAAC,EAChCP,CAAC,IAAKD,aAAa,CAACV,OAAO,EAAEW,CAAC,CAAC,CACjC;cACD+B,OAAO,CAACpC,IAAI,CAAC;YACf;UACF,CAAC;QACH,CAAC,CAAC;QACFN,OAAO,CAACS,MAAM,GAAG,SAAS;QAC1BV,qBAAqB,CAACC,OAAO,EAAGM,IAAI,IAAK;UACvC,IAAIA,IAAI,EAAE;YACR2E,eAAe,CAAC3E,IAAI,CAAC;UACvB;UACAgE,UAAU,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,UAAU,CAACc,KAAK,EAAE;QAClD,CAAC,CAAC;QACF,OAAO7B,YAAY,CAACtE,IAAI,EAAEe,OAAO,EAAE8C,MAAM,CAAC;MAC5C;MACA,OAAOS,YAAY,CAACtE,IAAI,EAAEuB,KAAK,EAAEsC,MAAM,CAAC;IAC1C,CAAC,CAAC,OAAOW,KAAK,EAAE;MACd,OAAOD,YAAY,CAACvE,IAAI,EAAEwE,KAAK,EAAEX,MAAM,CAAC;IAC1C,CAAC,SAAS;MACRmB,MAAM,GAAG,KAAK;IAChB;EACF,CAAC;EACD,MAAMoB,QAAQ,GAAIpG,IAAI,IAAKqC,eAAe,CAACoC,aAAa,CAACzE,IAAI,CAAC,CAAC;EAC/D,MAAMqG,OAAO,GAAIrG,IAAI,IAAK;IACxB,IAAIsG,OAAO,GAAG7D,UAAU,CAAClC,GAAG,CAACP,IAAI,CAAC;IAClC,IAAI,CAACsG,OAAO,EAAE;MACZA,OAAO,GAAGC,SAAS,CAACvG,IAAI,CAAC;IAC3B;IACA,OAAOsG,OAAO;EAChB,CAAC;EACD,MAAME,cAAc,GAAGA,CAACxG,IAAI,EAAEsG,OAAO,KAAK,CAACA,OAAO,CAACG,CAAC,CAACpC,IAAI,KAAK,CAACiC,OAAO,CAACI,CAAC,CAACrC,IAAI,IAAIiC,OAAO,CAACI,CAAC,CAACrC,IAAI,KAAK,CAAC,IAAIiC,OAAO,CAACI,CAAC,CAAClD,GAAG,CAACxD,IAAI,CAAC,CAAC;EAC7H,MAAM2G,OAAO,GAAI3G,IAAI,IAAK;IACxB,MAAMsG,OAAO,GAAG7D,UAAU,CAAClC,GAAG,CAACP,IAAI,CAAC;IACpC,IAAIsG,OAAO,IAAIE,cAAc,CAACxG,IAAI,EAAEsG,OAAO,CAAC,EAAE;MAC5CM,WAAW,CAAC5G,IAAI,CAAC;IACnB;EACF,CAAC;EACD,MAAM6G,mBAAmB,GAAI7G,IAAI,IAAK;IACpC,MAAMsG,OAAO,GAAG7D,UAAU,CAAClC,GAAG,CAACP,IAAI,CAAC;IACpCsG,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACI,CAAC,CAAC1C,OAAO,CAAE8C,SAAS,IAAK;MAC1D,IAAIA,SAAS,KAAK9G,IAAI,EAAE;QACtB,MAAMuD,aAAa,GAAGH,YAAY,CAAC0D,SAAS,CAAC;QAC7C,MAAMlD,aAAa,GAAGa,aAAa,CAACqC,SAAS,CAAC;QAC9C,IAAI,CAACvD,aAAa,IAAI,CAAC3B,gBAAgB,CAAC2B,aAAa,EAAEK,aAAa,CAAC,EAAE;UACrEiD,mBAAmB,CAACC,SAAS,CAAC;QAChC;MACF;IACF,CAAC,CAAC;EACJ,CAAC;EACD,MAAMC,cAAc,GAAG,SAAAA,CAAC/G,IAAI,EAAc;IACxC,IAAIgF,MAAM,GAAG,IAAI;IACjB,MAAMC,MAAM,GAAIpD,CAAC,IAAKQ,eAAe,CAACoC,aAAa,CAAC5C,CAAC,CAAC,CAAC;IACvD,MAAMmF,MAAM,GAAG,SAAAA,CAACnF,CAAC,EAAe;MAC9B,IAAIoF,CAAC;MAAC,SAAAC,KAAA,GAAAvB,SAAA,CAAAC,MAAA,EADcuB,KAAK,OAAAxC,KAAA,CAAAuC,KAAA,OAAAA,KAAA,WAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;QAALD,KAAK,CAAAC,KAAA,QAAAzB,SAAA,CAAAyB,KAAA;MAAA;MAEzB,IAAIvF,CAAC,KAAK7B,IAAI,EAAE;QACd,IAAI,CAACU,eAAe,CAACmB,CAAC,CAAC,EAAE;UACvB,MAAM,IAAIuD,KAAK,CAAC,mBAAmB,CAAC;QACtC;QACA,MAAM7B,aAAa,GAAGH,YAAY,CAACvB,CAAC,CAAC;QACrC,MAAM+B,aAAa,GAAGU,YAAY,CAACzC,CAAC,EAAEsF,KAAK,CAAC,CAAC,CAAC,CAAC;QAC/C,IAAI,CAAC5D,aAAa,IAAI,CAAC3B,gBAAgB,CAAC2B,aAAa,EAAEK,aAAa,CAAC,EAAE;UACrEiD,mBAAmB,CAAChF,CAAC,CAAC;QACxB;MACF,CAAC,MAAM;QACLoF,CAAC,GAAGF,cAAc,CAAClF,CAAC,EAAE,GAAGsF,KAAK,CAAC;MACjC;MACA,IAAI,CAACnC,MAAM,EAAE;QACXqC,YAAY,EAAE;MAChB;MACA,OAAOJ,CAAC;IACV,CAAC;IAAC,SAAAK,KAAA,GAAA3B,SAAA,CAAAC,MAAA,EArB6BC,IAAI,OAAAlB,KAAA,CAAA2C,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAJ1B,IAAI,CAAA0B,KAAA,QAAA5B,SAAA,CAAA4B,KAAA;IAAA;IAsBnC,MAAMC,MAAM,GAAGxH,IAAI,CAACE,KAAK,CAAC+E,MAAM,EAAE+B,MAAM,EAAE,GAAGnB,IAAI,CAAC;IAClDb,MAAM,GAAG,KAAK;IACd,OAAOwC,MAAM;EACf,CAAC;EACD,MAAMzB,SAAS,GAAG,SAAAA,CAAC/F,IAAI,EAAc;IAAA,SAAAyH,KAAA,GAAA9B,SAAA,CAAAC,MAAA,EAATC,IAAI,OAAAlB,KAAA,CAAA8C,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAJ7B,IAAI,CAAA6B,KAAA,QAAA/B,SAAA,CAAA+B,KAAA;IAAA;IAC9B,MAAMF,MAAM,GAAGT,cAAc,CAAC/G,IAAI,EAAE,GAAG6F,IAAI,CAAC;IAC5CwB,YAAY,EAAE;IACd,OAAOG,MAAM;EACf,CAAC;EACD,MAAMjB,SAAS,GAAGA,CAACvG,IAAI,EAAE2H,gBAAgB,KAAK;IAC5C,MAAMrB,OAAO,GAAG;MACdI,CAAC,EAAE,IAAIvD,GAAG,CAACwE,gBAAgB,IAAI,CAACA,gBAAgB,CAAC,CAAC;MAClDlB,CAAC,EAAE,eAAgB,IAAItD,GAAG;IAC5B,CAAC;IACDV,UAAU,CAACjC,GAAG,CAACR,IAAI,EAAEsG,OAAO,CAAC;IAC7B,IAAI,CAACvD,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;MAC9DJ,YAAY,CAACoC,GAAG,CAAClF,IAAI,CAAC;IACxB;IACAyE,aAAa,CAACzE,IAAI,CAAC,CAACkE,CAAC,CAACF,OAAO,CAAC,CAACU,CAAC,EAAE7C,CAAC,KAAK;MACtC,MAAM+F,QAAQ,GAAGnF,UAAU,CAAClC,GAAG,CAACsB,CAAC,CAAC;MAClC,IAAI+F,QAAQ,EAAE;QACZA,QAAQ,CAAClB,CAAC,CAACxB,GAAG,CAAClF,IAAI,CAAC;MACtB,CAAC,MAAM;QACL,IAAI6B,CAAC,KAAK7B,IAAI,EAAE;UACduG,SAAS,CAAC1E,CAAC,EAAE7B,IAAI,CAAC;QACpB;MACF;IACF,CAAC,CAAC;IACFyE,aAAa,CAACzE,IAAI,CAAC;IACnB,IAAIW,sBAAsB,CAACX,IAAI,CAAC,IAAIA,IAAI,CAAC6H,OAAO,EAAE;MAChD,MAAMC,SAAS,GAAG9H,IAAI,CAAC6H,OAAO,CAAC;QAAA,SAAAE,KAAA,GAAApC,SAAA,CAAAC,MAAA,EAAIC,IAAI,OAAAlB,KAAA,CAAAoD,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;UAAJnC,IAAI,CAAAmC,KAAA,IAAArC,SAAA,CAAAqC,KAAA;QAAA;QAAA,OAAKjC,SAAS,CAAC/F,IAAI,EAAE,GAAG6F,IAAI,CAAC;MAAA,EAAC;MACrE,IAAIiC,SAAS,EAAE;QACbxB,OAAO,CAAC2B,CAAC,GAAGH,SAAS;MACvB;IACF;IACA,OAAOxB,OAAO;EAChB,CAAC;EACD,MAAMM,WAAW,GAAI5G,IAAI,IAAK;IAC5B,IAAIkI,EAAE;IACN,MAAMJ,SAAS,GAAG,CAACI,EAAE,GAAGzF,UAAU,CAAClC,GAAG,CAACP,IAAI,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGkI,EAAE,CAACD,CAAC;IACrE,IAAIH,SAAS,EAAE;MACbA,SAAS,EAAE;IACb;IACArF,UAAU,CAACtB,MAAM,CAACnB,IAAI,CAAC;IACvB,IAAI,CAAC+C,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;MAC9DJ,YAAY,CAAC3B,MAAM,CAACnB,IAAI,CAAC;IAC3B;IACA,MAAMsC,SAAS,GAAGc,YAAY,CAACpD,IAAI,CAAC;IACpC,IAAIsC,SAAS,EAAE;MACb,IAAIH,mBAAmB,CAACG,SAAS,CAAC,EAAE;QAClClB,aAAa,CAACkB,SAAS,CAACL,CAAC,CAAC;MAC5B;MACAK,SAAS,CAAC4B,CAAC,CAACF,OAAO,CAAC,CAACU,CAAC,EAAE7C,CAAC,KAAK;QAC5B,IAAIA,CAAC,KAAK7B,IAAI,EAAE;UACd,MAAMsG,OAAO,GAAG7D,UAAU,CAAClC,GAAG,CAACsB,CAAC,CAAC;UACjC,IAAIyE,OAAO,EAAE;YACXA,OAAO,CAACI,CAAC,CAACvF,MAAM,CAACnB,IAAI,CAAC;YACtB,IAAIwG,cAAc,CAAC3E,CAAC,EAAEyE,OAAO,CAAC,EAAE;cAC9BM,WAAW,CAAC/E,CAAC,CAAC;YAChB;UACF;QACF;MACF,CAAC,CAAC;IACJ,CAAC,MAAM,IAAI,CAACkB,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;MACrEiB,OAAO,CAACC,IAAI,CAAC,4CAA4C,EAAEpE,IAAI,CAAC;IAClE;EACF,CAAC;EACD,MAAMmI,iBAAiB,GAAGA,CAACnI,IAAI,EAAEsC,SAAS,EAAE8F,gBAAgB,KAAK;IAC/D,MAAMvE,MAAM,GAAG,IAAIV,GAAG,CAACb,SAAS,CAAC4B,CAAC,CAACmE,IAAI,EAAE,CAAC;IAC1CD,gBAAgB,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,gBAAgB,CAACpE,OAAO,CAAC,CAACU,CAAC,EAAE7C,CAAC,KAAK;MACrE,IAAIgC,MAAM,CAACL,GAAG,CAAC3B,CAAC,CAAC,EAAE;QACjBgC,MAAM,CAAC1C,MAAM,CAACU,CAAC,CAAC;QAChB;MACF;MACA,MAAMyE,OAAO,GAAG7D,UAAU,CAAClC,GAAG,CAACsB,CAAC,CAAC;MACjC,IAAIyE,OAAO,EAAE;QACXA,OAAO,CAACI,CAAC,CAACvF,MAAM,CAACnB,IAAI,CAAC;QACtB,IAAIwG,cAAc,CAAC3E,CAAC,EAAEyE,OAAO,CAAC,EAAE;UAC9BM,WAAW,CAAC/E,CAAC,CAAC;QAChB;MACF;IACF,CAAC,CAAC;IACFgC,MAAM,CAACG,OAAO,CAAEnC,CAAC,IAAK;MACpB,MAAMyE,OAAO,GAAG7D,UAAU,CAAClC,GAAG,CAACsB,CAAC,CAAC;MACjC,IAAIyE,OAAO,EAAE;QACXA,OAAO,CAACI,CAAC,CAACxB,GAAG,CAAClF,IAAI,CAAC;MACrB,CAAC,MAAM,IAAIyC,UAAU,CAACe,GAAG,CAACxD,IAAI,CAAC,EAAE;QAC/BuG,SAAS,CAAC1E,CAAC,EAAE7B,IAAI,CAAC;MACpB;IACF,CAAC,CAAC;EACJ,CAAC;EACD,MAAMqH,YAAY,GAAGA,CAAA,KAAM;IACzB,OAAO3E,UAAU,CAAC2B,IAAI,EAAE;MACtB,MAAMiE,OAAO,GAAG3D,KAAK,CAACC,IAAI,CAAClC,UAAU,CAAC;MACtCA,UAAU,CAAC6F,KAAK,EAAE;MAClBD,OAAO,CAACtE,OAAO,CAACwE,KAAA,IAA2B;QAAA,IAA1B,CAACxI,IAAI,EAAEuD,aAAa,CAAC,GAAAiF,KAAA;QACpC,MAAMlG,SAAS,GAAGc,YAAY,CAACpD,IAAI,CAAC;QACpC,IAAIsC,SAAS,EAAE;UACb,IAAIA,SAAS,CAAC4B,CAAC,MAAMX,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,aAAa,CAACW,CAAC,CAAC,EAAE;YACtEiE,iBAAiB,CAACnI,IAAI,EAAEsC,SAAS,EAAEiB,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,aAAa,CAACW,CAAC,CAAC;UACtF;UACA,MAAMoC,OAAO,GAAG7D,UAAU,CAAClC,GAAG,CAACP,IAAI,CAAC;UACpC,IAAIsG,OAAO,IAAI;UAAC;UAChB;UACC/C,aAAa,IAAI,CAACpB,mBAAmB,CAACoB,aAAa,CAAC,KAAK3B,gBAAgB,CAAC2B,aAAa,EAAEjB,SAAS,CAAC,IAAIJ,gBAAgB,CAACqB,aAAa,EAAEjB,SAAS,CAAC,CAAC,CAAC,EAAE;YACpJgE,OAAO,CAACG,CAAC,CAACzC,OAAO,CAAEyE,QAAQ,IAAKA,QAAQ,EAAE,CAAC;UAC7C;QACF,CAAC,MAAM,IAAI,CAAC1F,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;UACrEiB,OAAO,CAACC,IAAI,CAAC,8BAA8B,CAAC;QAC9C;MACF,CAAC,CAAC;IACJ;IACA,IAAI,CAACrB,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;MAC9DN,cAAc,CAACoB,OAAO,CAAEyC,CAAC,IAAKA,CAAC,EAAE,CAAC;MAClC5D,cAAc,CAACmB,OAAO,CAAEyC,CAAC,IAAKA,CAAC,CAAC,OAAO,CAAC,CAAC;IAC3C;EACF,CAAC;EACD,MAAMiC,aAAa,GAAGA,CAAC1I,IAAI,EAAEyI,QAAQ,KAAK;IACxC,MAAMnC,OAAO,GAAGD,OAAO,CAACrG,IAAI,CAAC;IAC7BqH,YAAY,EAAE;IACd,MAAMsB,SAAS,GAAGrC,OAAO,CAACG,CAAC;IAC3BkC,SAAS,CAACzD,GAAG,CAACuD,QAAQ,CAAC;IACvB,IAAI,CAAC1F,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;MAC9DL,cAAc,CAACmB,OAAO,CAAEyC,CAAC,IAAKA,CAAC,CAAC,KAAK,CAAC,CAAC;IACzC;IACA,OAAO,MAAM;MACXkC,SAAS,CAACxH,MAAM,CAACsH,QAAQ,CAAC;MAC1B9B,OAAO,CAAC3G,IAAI,CAAC;MACb,IAAI,CAAC+C,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;QAC9DL,cAAc,CAACmB,OAAO,CAAEyC,CAAC,IAAKA,CAAC,CAAC,OAAO,CAAC,CAAC;MAC3C;IACF,CAAC;EACH,CAAC;EACD,IAAI,CAAC1D,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;IAC9D,OAAO;MACL3C,GAAG,EAAE6F,QAAQ;MACb5F,GAAG,EAAEuF,SAAS;MACd6C,GAAG,EAAEF,aAAa;MAClB;MACAG,mBAAmB,EAAGpC,CAAC,IAAK;QAC1BtC,OAAO,CAACC,IAAI,CACV,gIAAgI,CACjI;QACDxB,cAAc,CAACsC,GAAG,CAACuB,CAAC,CAAC;QACrB,OAAO,MAAM;UACX7D,cAAc,CAACzB,MAAM,CAACsF,CAAC,CAAC;QAC1B,CAAC;MACH,CAAC;MACDqC,mBAAmB,EAAGrC,CAAC,IAAK;QAC1B5D,cAAc,CAACqC,GAAG,CAACuB,CAAC,CAAC;QACrB,OAAO,MAAM;UACX5D,cAAc,CAAC1B,MAAM,CAACsF,CAAC,CAAC;QAC1B,CAAC;MACH,CAAC;MACDsC,qBAAqB,EAAEA,CAAA,KAAMjG,YAAY,CAACkG,MAAM,EAAE;MAClDC,kBAAkB,EAAGpH,CAAC,IAAKW,YAAY,CAACjC,GAAG,CAACsB,CAAC,CAAC;MAC9CqH,eAAe,EAAGrH,CAAC,IAAKY,UAAU,CAAClC,GAAG,CAACsB,CAAC,CAAC;MACzCsH,iBAAiB,EAAGH,MAAM,IAAK;QAC7B,KAAK,MAAM,CAAChJ,IAAI,EAAEuB,KAAK,CAAC,IAAIyH,MAAM,EAAE;UAClC,IAAItI,eAAe,CAACV,IAAI,CAAC,EAAE;YACzBsE,YAAY,CAACtE,IAAI,EAAEuB,KAAK,CAAC;YACzBsF,mBAAmB,CAAC7G,IAAI,CAAC;UAC3B;QACF;QACAqH,YAAY,EAAE;MAChB;IACF,CAAC;EACH;EACA,OAAO;IACL9G,GAAG,EAAE6F,QAAQ;IACb5F,GAAG,EAAEuF,SAAS;IACd6C,GAAG,EAAEF;EACP,CAAC;AACH,CAAC;AACD,IAAIU,YAAY;AAChB,MAAMC,eAAe,GAAGA,CAAA,KAAM;EAC5B,IAAI,CAACD,YAAY,EAAE;IACjBA,YAAY,GAAG7G,WAAW,EAAE;EAC9B;EACA,OAAO6G,YAAY;AACrB,CAAC;AAED,SAASpJ,IAAI,EAAEuC,WAAW,EAAE8G,eAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}