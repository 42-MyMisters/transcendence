{"ast":null,"code":"import ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\nconst StoreContext = createContext(void 0);\nconst useStore = options => {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nconst Provider = _ref => {\n  let {\n    children,\n    store\n  } = _ref;\n  const storeRef = useRef();\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(StoreContext.Provider, {\n    value: store || storeRef.current\n  }, children);\n};\nconst isPromise = x => x instanceof Promise;\nconst use = ReactExports.use || (promise => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    promise.status = \"pending\";\n    promise.then(v => {\n      promise.status = \"fulfilled\";\n      promise.value = v;\n    }, e => {\n      promise.status = \"rejected\";\n      promise.reason = e;\n    });\n    throw promise;\n  }\n});\nfunction useAtomValue(atom, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(prev => {\n    const nextValue = store.get(atom);\n    if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n      return prev;\n    }\n    return [nextValue, store, atom];\n  }, void 0, () => [store.get(atom), store, atom]);\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay]);\n  useDebugValue(value);\n  return isPromise(value) ? use(value) : value;\n}\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(function () {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n      throw new Error(\"not writable atom\");\n    }\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return store.set(atom, ...args);\n  }, [store, atom]);\n  return setAtom;\n}\nfunction useAtom(atom, options) {\n  return [useAtomValue(atom, options),\n  // We do wrong type assertion here, which results in throwing an error.\n  useSetAtom(atom, options)];\n}\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };","map":{"version":3,"names":["ReactExports","createContext","useContext","useRef","createElement","useReducer","useEffect","useDebugValue","useCallback","getDefaultStore","createStore","StoreContext","useStore","options","store","Provider","_ref","children","storeRef","current","value","isPromise","x","Promise","use","promise","status","reason","then","v","e","useAtomValue","atom","valueFromReducer","storeFromReducer","atomFromReducer","rerender","prev","nextValue","get","Object","is","delay","unsub","sub","setTimeout","useSetAtom","setAtom","import","meta","env","MODE","Error","_len","arguments","length","args","Array","_key","set","useAtom"],"sources":["/data/front/node_modules/jotai/esm/react.mjs"],"sourcesContent":["import ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\n\nconst StoreContext = createContext(void 0);\nconst useStore = (options) => {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nconst Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = useRef();\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n};\n\nconst isPromise = (x) => x instanceof Promise;\nconst use = ReactExports.use || ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n    throw promise;\n  }\n});\nfunction useAtomValue(atom, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay]);\n  useDebugValue(value);\n  return isPromise(value) ? use(value) : value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}