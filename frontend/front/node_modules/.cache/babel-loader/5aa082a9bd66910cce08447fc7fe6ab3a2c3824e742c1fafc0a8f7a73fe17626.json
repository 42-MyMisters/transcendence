{"ast":null,"code":"// config.js (c) 2010-2022 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-config\n\n// Dependencies\nvar DeferredConfig = require('../defer').DeferredConfig,\n  RawConfig = require('../raw').RawConfig,\n  Parser = require('../parser'),\n  Utils = require('util'),\n  Path = require('path'),\n  FileSystem = require('fs');\n\n// Static members\nvar DEFAULT_CLONE_DEPTH = 20,\n  CONFIG_DIR,\n  NODE_ENV,\n  APP_INSTANCE,\n  CONFIG_SKIP_GITCRYPT,\n  NODE_ENV_VAR_NAME,\n  NODE_CONFIG_PARSER,\n  env = {},\n  configSources = [],\n  // Configuration sources - array of {name, original, parsed}\n  checkMutability = true,\n  // Check for mutability/immutability on first get\n  gitCryptTestRegex = /^.GITCRYPT/; // regular expression to test for gitcrypt files.\n\n/**\n * <p>Application Configurations</p>\n *\n * <p>\n * The config module exports a singleton object representing all\n * configurations for this application deployment.\n * </p>\n *\n * <p>\n * Application configurations are stored in files within the config directory\n * of your application.  The default configuration file is loaded, followed\n * by files specific to the deployment type (development, testing, staging,\n * production, etc.).\n * </p>\n *\n * <p>\n * For example, with the following config/default.yaml file:\n * </p>\n *\n * <pre>\n *   ...\n *   customer:\n *     &nbsp;&nbsp;initialCredit: 500\n *     &nbsp;&nbsp;db:\n *       &nbsp;&nbsp;&nbsp;&nbsp;name: customer\n *       &nbsp;&nbsp;&nbsp;&nbsp;port: 5984\n *   ...\n * </pre>\n *\n * <p>\n * The following code loads the customer section into the CONFIG variable:\n * <p>\n *\n * <pre>\n *   var CONFIG = require('config').customer;\n *   ...\n *   newCustomer.creditLimit = CONFIG.initialCredit;\n *   database.open(CONFIG.db.name, CONFIG.db.port);\n *   ...\n * </pre>\n *\n * @module config\n * @class Config\n */\n\n/**\n * <p>Get the configuration object.</p>\n *\n * <p>\n * The configuration object is a shared singleton object within the application,\n * attained by calling require('config').\n * </p>\n *\n * <p>\n * Usually you'll specify a CONFIG variable at the top of your .js file\n * for file/module scope. If you want the root of the object, you can do this:\n * </p>\n * <pre>\n * var CONFIG = require('config');\n * </pre>\n *\n * <p>\n * Sometimes you only care about a specific sub-object within the CONFIG\n * object.  In that case you could do this at the top of your file:\n * </p>\n * <pre>\n * var CONFIG = require('config').customer;\n * or\n * var CUSTOMER_CONFIG = require('config').customer;\n * </pre>\n *\n * <script type=\"text/javascript\">\n *   document.getElementById(\"showProtected\").style.display = \"block\";\n * </script>\n *\n * @method constructor\n * @return CONFIG {object} - The top level configuration object\n */\nvar Config = function () {\n  var t = this;\n\n  // Bind all utility functions to this\n  for (var fnName in util) {\n    if (typeof util[fnName] === 'function') {\n      util[fnName] = util[fnName].bind(t);\n    }\n  }\n\n  // Merge configurations into this\n  util.extendDeep(t, util.loadFileConfigs());\n  util.attachProtoDeep(t);\n\n  // Perform strictness checks and possibly throw an exception.\n  util.runStrictnessChecks(t);\n};\n\n/**\n * Utilities are under the util namespace vs. at the top level\n */\nvar util = Config.prototype.util = {};\n\n/**\n * Underlying get mechanism\n *\n * @private\n * @method getImpl\n * @param object {object} - Object to get the property for\n * @param property {string|string[]} - The property name to get (as an array or '.' delimited string)\n * @return value {*} - Property value, including undefined if not defined.\n */\nvar getImpl = function (object, property) {\n  var t = this,\n    elems = Array.isArray(property) ? property : property.split('.'),\n    name = elems[0],\n    value = object[name];\n  if (elems.length <= 1) {\n    return value;\n  }\n  // Note that typeof null === 'object'\n  if (value === null || typeof value !== 'object') {\n    return undefined;\n  }\n  return getImpl(value, elems.slice(1));\n};\n\n/**\n * <p>Get a configuration value</p>\n *\n * <p>\n * This will return the specified property value, throwing an exception if the\n * configuration isn't defined.  It is used to assure configurations are defined\n * before being used, and to prevent typos.\n * </p>\n *\n * @method get\n * @param property {string} - The configuration property to get. Can include '.' sub-properties.\n * @return value {*} - The property value\n */\nConfig.prototype.get = function (property) {\n  if (property === null || property === undefined) {\n    throw new Error(\"Calling config.get with null or undefined argument\");\n  }\n\n  // Make configurations immutable after first get (unless disabled)\n  if (checkMutability) {\n    if (!util.initParam('ALLOW_CONFIG_MUTATIONS', false)) {\n      util.makeImmutable(config);\n    }\n    checkMutability = false;\n  }\n  var t = this,\n    value = getImpl(t, property);\n\n  // Produce an exception if the property doesn't exist\n  if (value === undefined) {\n    throw new Error('Configuration property \"' + property + '\" is not defined');\n  }\n\n  // Return the value\n  return value;\n};\n\n/**\n * Test that a configuration parameter exists\n *\n * <pre>\n *    var config = require('config');\n *    if (config.has('customer.dbName')) {\n *      console.log('Customer database name: ' + config.customer.dbName);\n *    }\n * </pre>\n *\n * @method has\n * @param property {string} - The configuration property to test. Can include '.' sub-properties.\n * @return isPresent {boolean} - True if the property is defined, false if not defined.\n */\nConfig.prototype.has = function (property) {\n  // While get() throws an exception for undefined input, has() is designed to test validity, so false is appropriate\n  if (property === null || property === undefined) {\n    return false;\n  }\n  var t = this;\n  return getImpl(t, property) !== undefined;\n};\n\n/**\n * <p>\n * Set default configurations for a node.js module.\n * </p>\n *\n * <p>\n * This allows module developers to attach their configurations onto the\n * default configuration object so they can be configured by the consumers\n * of the module.\n * </p>\n *\n * <p>Using the function within your module:</p>\n * <pre>\n *   var CONFIG = require(\"config\");\n *   CONFIG.util.setModuleDefaults(\"MyModule\", {\n *   &nbsp;&nbsp;templateName: \"t-50\",\n *   &nbsp;&nbsp;colorScheme: \"green\"\n *   });\n * <br>\n *   // Template name may be overridden by application config files\n *   console.log(\"Template: \" + CONFIG.MyModule.templateName);\n * </pre>\n *\n * <p>\n * The above example results in a \"MyModule\" element of the configuration\n * object, containing an object with the specified default values.\n * </p>\n *\n * @method setModuleDefaults\n * @param moduleName {string} - Name of your module.\n * @param defaultProperties {object} - The default module configuration.\n * @return moduleConfig {object} - The module level configuration object.\n */\nutil.setModuleDefaults = function (moduleName, defaultProperties) {\n  // Copy the properties into a new object\n  var t = this,\n    moduleConfig = util.cloneDeep(defaultProperties);\n\n  // Set module defaults into the first sources element\n  if (configSources.length === 0 || configSources[0].name !== 'Module Defaults') {\n    configSources.splice(0, 0, {\n      name: 'Module Defaults',\n      parsed: {}\n    });\n  }\n  util.setPath(configSources[0].parsed, moduleName.split('.'), {});\n  util.extendDeep(getImpl(configSources[0].parsed, moduleName), defaultProperties);\n\n  // Create a top level config for this module if it doesn't exist\n  util.setPath(t, moduleName.split('.'), getImpl(t, moduleName) || {});\n\n  // Extend local configurations into the module config\n  util.extendDeep(moduleConfig, getImpl(t, moduleName));\n\n  // Merge the extended configs without replacing the original\n  util.extendDeep(getImpl(t, moduleName), moduleConfig);\n\n  // reset the mutability check for \"config.get\" method.\n  // we are not making t[moduleName] immutable immediately,\n  // since there might be more modifications before the first config.get\n  if (!util.initParam('ALLOW_CONFIG_MUTATIONS', false)) {\n    checkMutability = true;\n  }\n\n  // Attach handlers & watchers onto the module config object\n  return util.attachProtoDeep(getImpl(t, moduleName));\n};\n\n/**\n * <p>Make a configuration property hidden so it doesn't appear when enumerating\n * elements of the object.</p>\n *\n * <p>\n * The property still exists and can be read from and written to, but it won't\n * show up in for ... in loops, Object.keys(), or JSON.stringify() type methods.\n * </p>\n *\n * <p>\n * If the property already exists, it will be made hidden.  Otherwise it will\n * be created as a hidden property with the specified value.\n * </p>\n *\n * <p><i>\n * This method was built for hiding configuration values, but it can be applied\n * to <u>any</u> javascript object.\n * </i></p>\n *\n * <p>Example:</p>\n * <pre>\n *   var CONFIG = require('config');\n *   ...\n *\n *   // Hide the Amazon S3 credentials\n *   CONFIG.util.makeHidden(CONFIG.amazonS3, 'access_id');\n *   CONFIG.util.makeHidden(CONFIG.amazonS3, 'secret_key');\n * </pre>\n *\n * @method makeHidden\n * @param object {object} - The object to make a hidden property into.\n * @param property {string} - The name of the property to make hidden.\n * @param value {*} - (optional) Set the property value to this (otherwise leave alone)\n * @return object {object} - The original object is returned - for chaining.\n */\nutil.makeHidden = function (object, property, value) {\n  // If the new value isn't specified, just mark the property as hidden\n  if (typeof value === 'undefined') {\n    Object.defineProperty(object, property, {\n      enumerable: false\n    });\n  }\n  // Otherwise set the value and mark it as hidden\n  else {\n    Object.defineProperty(object, property, {\n      value: value,\n      enumerable: false\n    });\n  }\n  return object;\n};\n\n/**\n * <p>Make a javascript object property immutable (assuring it cannot be changed\n * from the current value).</p>\n * <p>\n * If the specified property is an object, all attributes of that object are\n * made immutable, including properties of contained objects, recursively.\n * If a property name isn't supplied, all properties of the object are made\n * immutable.\n * </p>\n * <p>\n *\n * </p>\n * <p>\n * New properties can be added to the object and those properties will not be\n * immutable unless this method is called on those new properties.\n * </p>\n * <p>\n * This operation cannot be undone.\n * </p>\n *\n * <p>Example:</p>\n * <pre>\n *   var config = require('config');\n *   var myObject = {hello:'world'};\n *   config.util.makeImmutable(myObject);\n * </pre>\n *\n * @method makeImmutable\n * @param object {object} - The object to specify immutable properties for\n * @param [property] {string | [string]} - The name of the property (or array of names) to make immutable.\n *        If not provided, all owned properties of the object are made immutable.\n * @param [value] {* | [*]} - Property value (or array of values) to set\n *        the property to before making immutable. Only used when setting a single\n *        property. Retained for backward compatibility.\n * @return object {object} - The original object is returned - for chaining.\n */\nutil.makeImmutable = function (object, property, value) {\n  if (Buffer.isBuffer(object)) {\n    return object;\n  }\n  var properties = null;\n\n  // Backwards compatibility mode where property/value can be specified\n  if (typeof property === 'string') {\n    return Object.defineProperty(object, property, {\n      value: typeof value === 'undefined' ? object[property] : value,\n      writable: false,\n      configurable: false\n    });\n  }\n\n  // Get the list of properties to work with\n  if (Array.isArray(property)) {\n    properties = property;\n  } else {\n    properties = Object.keys(object);\n  }\n\n  // Process each property\n  for (var i = 0; i < properties.length; i++) {\n    var propertyName = properties[i],\n      value = object[propertyName];\n    if (value instanceof RawConfig) {\n      Object.defineProperty(object, propertyName, {\n        value: value.resolve(),\n        writable: false,\n        configurable: false\n      });\n    } else if (Array.isArray(value)) {\n      // Ensure object items of this array are also immutable.\n      value.forEach((item, index) => {\n        if (util.isObject(item) || Array.isArray(item)) util.makeImmutable(item);\n      });\n      Object.defineProperty(object, propertyName, {\n        value: Object.freeze(value)\n      });\n    } else {\n      // Call recursively if an object.\n      if (util.isObject(value)) {\n        // Create a proxy, to capture user updates of configuration options, and throw an exception for awareness, as per:\n        // https://github.com/lorenwest/node-config/issues/514\n        value = new Proxy(util.makeImmutable(value), {\n          set(target, name) {\n            const message = Reflect.has(target, name) ? 'update' : 'add';\n            // Notify the user.\n            throw Error(`Can not ${message} runtime configuration property: \"${name}\". Configuration objects are immutable unless ALLOW_CONFIG_MUTATIONS is set.`);\n          }\n        });\n      }\n      Object.defineProperty(object, propertyName, {\n        value: value,\n        writable: false,\n        configurable: false\n      });\n\n      // Ensure new properties can not be added, as per:\n      // https://github.com/lorenwest/node-config/issues/505\n      Object.preventExtensions(object[propertyName]);\n    }\n  }\n  return object;\n};\n\n/**\n * Return the sources for the configurations\n *\n * <p>\n * All sources for configurations are stored in an array of objects containing\n * the source name (usually the filename), the original source (as a string),\n * and the parsed source as an object.\n * </p>\n *\n * @method getConfigSources\n * @return configSources {Array[Object]} - An array of objects containing\n *    name, original, and parsed elements\n */\nutil.getConfigSources = function () {\n  var t = this;\n  return configSources.slice(0);\n};\n\n/**\n * Looks into an options object for a specific attribute\n *\n * <p>\n * This method looks into the options object, and if an attribute is defined, returns it,\n * and if not, returns the default value\n * </p>\n *\n * @method getOption\n * @param options {Object | undefined} the options object\n * @param optionName {string} the attribute name to look for\n * @param defaultValue { any } the default in case the options object is empty, or the attribute does not exist.\n * @return options[optionName] if defined, defaultValue if not.\n */\nutil.getOption = function (options, optionName, defaultValue) {\n  if (options !== undefined && options[optionName] !== undefined) {\n    return options[optionName];\n  } else {\n    return defaultValue;\n  }\n};\n\n/**\n * Load the individual file configurations.\n *\n * <p>\n * This method builds a map of filename to the configuration object defined\n * by the file.  The search order is:\n * </p>\n *\n * <pre>\n *   default.EXT\n *   (deployment).EXT\n *   (hostname).EXT\n *   (hostname)-(deployment).EXT\n *   local.EXT\n *   local-(deployment).EXT\n *   runtime.json\n * </pre>\n *\n * <p>\n * EXT can be yml, yaml, coffee, iced, json, cson or js signifying the file type.\n * yaml (and yml) is in YAML format, coffee is a coffee-script, iced is iced-coffee-script,\n * json is in JSON format, cson is in CSON format, properties is in .properties format\n * (http://en.wikipedia.org/wiki/.properties), and js is a javascript executable file that is\n * require()'d with module.exports being the config object.\n * </p>\n *\n * <p>\n * hostname is the $HOST environment variable (or --HOST command line parameter)\n * if set, otherwise the $HOSTNAME environment variable (or --HOSTNAME command\n * line parameter) if set, otherwise the hostname found from\n * require('os').hostname().\n * </p>\n *\n * <p>\n * Once a hostname is found, everything from the first period ('.') onwards\n * is removed. For example, abc.example.com becomes abc\n * </p>\n *\n * <p>\n * (deployment) is the deployment type, found in the $NODE_ENV environment\n * variable (which can be overridden by using $NODE_CONFIG_ENV\n * environment variable). Defaults to 'development'.\n * </p>\n *\n * <p>\n * The runtime.json file contains configuration changes made at runtime either\n * manually, or by the application setting a configuration value.\n * </p>\n *\n * <p>\n * If the $NODE_APP_INSTANCE environment variable (or --NODE_APP_INSTANCE\n * command line parameter) is set, then files with this appendage will be loaded.\n * See the Multiple Application Instances section of the main documentation page\n * for more information.\n * </p>\n *\n * @protected\n * @method loadFileConfigs\n * @param configDir { string | null } the path to the directory containing the configurations to load\n * @param options { object | undefined } parsing options. Current supported option: skipConfigSources: true|false\n * @return config {Object} The configuration object\n */\nutil.loadFileConfigs = function (configDir, options) {\n  // Initialize\n  var t = this,\n    config = {};\n\n  // Specify variables that can be used to define the environment\n  var node_env_var_names = ['NODE_CONFIG_ENV', 'NODE_ENV'];\n\n  // Loop through the variables to try and set environment\n  for (const node_env_var_name of node_env_var_names) {\n    NODE_ENV = util.initParam(node_env_var_name);\n    if (!!NODE_ENV) {\n      NODE_ENV_VAR_NAME = node_env_var_name;\n      break;\n    }\n  }\n\n  // If we haven't successfully set the environment using the variables, we'll default it\n  if (!NODE_ENV) {\n    NODE_ENV = 'development';\n  }\n  node_env_var_names.forEach(node_env_var_name => {\n    env[node_env_var_name] = NODE_ENV;\n  });\n\n  // Split files name, for loading multiple files.\n  NODE_ENV = NODE_ENV.split(',');\n  var dir = configDir || util.initParam('NODE_CONFIG_DIR', Path.join(process.cwd(), 'config'));\n  dir = _toAbsolutePath(dir);\n  APP_INSTANCE = util.initParam('NODE_APP_INSTANCE');\n  CONFIG_SKIP_GITCRYPT = util.initParam('CONFIG_SKIP_GITCRYPT');\n\n  // This is for backward compatibility\n  var runtimeFilename = util.initParam('NODE_CONFIG_RUNTIME_JSON', Path.join(dir, 'runtime.json'));\n  NODE_CONFIG_PARSER = util.initParam('NODE_CONFIG_PARSER');\n  if (NODE_CONFIG_PARSER) {\n    try {\n      var parserModule = Path.isAbsolute(NODE_CONFIG_PARSER) ? NODE_CONFIG_PARSER : Path.join(dir, NODE_CONFIG_PARSER);\n      Parser = require(parserModule);\n    } catch (e) {\n      console.warn('Failed to load config parser from ' + NODE_CONFIG_PARSER);\n      console.log(e);\n    }\n  }\n  var HOST = util.initParam('HOST');\n  var HOSTNAME = util.initParam('HOSTNAME');\n\n  // Determine the host name from the OS module, $HOST, or $HOSTNAME\n  // Remove any . appendages, and default to null if not set\n  try {\n    var hostName = HOST || HOSTNAME;\n    if (!hostName) {\n      var OS = require('os');\n      hostName = OS.hostname();\n    }\n  } catch (e) {\n    hostName = '';\n  }\n\n  // Store the hostname that won.\n  env.HOSTNAME = hostName;\n\n  // Read each file in turn\n  var baseNames = ['default'].concat(NODE_ENV);\n\n  // #236: Also add full hostname when they are different.\n  if (hostName) {\n    var firstDomain = hostName.split('.')[0];\n    NODE_ENV.forEach(function (env) {\n      // Backward compatibility\n      baseNames.push(firstDomain, firstDomain + '-' + env);\n\n      // Add full hostname when it is not the same\n      if (hostName !== firstDomain) {\n        baseNames.push(hostName, hostName + '-' + env);\n      }\n    });\n  }\n  NODE_ENV.forEach(function (env) {\n    baseNames.push('local', 'local-' + env);\n  });\n  var allowedFiles = {};\n  var resolutionIndex = 1;\n  var extNames = Parser.getFilesOrder();\n  baseNames.forEach(function (baseName) {\n    extNames.forEach(function (extName) {\n      allowedFiles[baseName + '.' + extName] = resolutionIndex++;\n      if (APP_INSTANCE) {\n        allowedFiles[baseName + '-' + APP_INSTANCE + '.' + extName] = resolutionIndex++;\n      }\n    });\n  });\n  var locatedFiles = util.locateMatchingFiles(dir, allowedFiles);\n  locatedFiles.forEach(function (fullFilename) {\n    var configObj = util.parseFile(fullFilename, options);\n    if (configObj) {\n      util.extendDeep(config, configObj);\n    }\n  });\n\n  // Override configurations from the $NODE_CONFIG environment variable\n  // NODE_CONFIG only applies to the base config\n  if (!configDir) {\n    var envConfig = {};\n    CONFIG_DIR = dir;\n    if (process.env.NODE_CONFIG) {\n      try {\n        envConfig = JSON.parse(process.env.NODE_CONFIG);\n      } catch (e) {\n        console.error('The $NODE_CONFIG environment variable is malformed JSON');\n      }\n      util.extendDeep(config, envConfig);\n      var skipConfigSources = util.getOption(options, 'skipConfigSources', false);\n      if (!skipConfigSources) {\n        configSources.push({\n          name: \"$NODE_CONFIG\",\n          parsed: envConfig\n        });\n      }\n    }\n\n    // Override configurations from the --NODE_CONFIG command line\n    var cmdLineConfig = util.getCmdLineArg('NODE_CONFIG');\n    if (cmdLineConfig) {\n      try {\n        cmdLineConfig = JSON.parse(cmdLineConfig);\n      } catch (e) {\n        console.error('The --NODE_CONFIG={json} command line argument is malformed JSON');\n      }\n      util.extendDeep(config, cmdLineConfig);\n      var skipConfigSources = util.getOption(options, 'skipConfigSources', false);\n      if (!skipConfigSources) {\n        configSources.push({\n          name: \"--NODE_CONFIG argument\",\n          parsed: cmdLineConfig\n        });\n      }\n    }\n\n    // Place the mixed NODE_CONFIG into the environment\n    env['NODE_CONFIG'] = JSON.stringify(util.extendDeep(envConfig, cmdLineConfig, {}));\n  }\n\n  // Override with environment variables if there is a custom-environment-variables.EXT mapping file\n  var customEnvVars = util.getCustomEnvVars(dir, extNames);\n  util.extendDeep(config, customEnvVars);\n\n  // Extend the original config with the contents of runtime.json (backwards compatibility)\n  var runtimeJson = util.parseFile(runtimeFilename) || {};\n  util.extendDeep(config, runtimeJson);\n  util.resolveDeferredConfigs(config);\n\n  // Return the configuration object\n  return config;\n};\n\n/**\n * Return a list of fullFilenames who exists in allowedFiles\n * Ordered according to allowedFiles argument specifications\n *\n * @protected\n * @method locateMatchingFiles\n * @param configDirs {string}   the config dir, or multiple dirs separated by a column (:)\n * @param allowedFiles {object} an object. keys and supported filenames\n *                              and values are the position in the resolution order\n * @returns {string[]}          fullFilenames - path + filename\n */\nutil.locateMatchingFiles = function (configDirs, allowedFiles) {\n  return configDirs.split(Path.delimiter).reduce(function (files, configDir) {\n    if (configDir) {\n      configDir = _toAbsolutePath(configDir);\n      try {\n        FileSystem.readdirSync(configDir).forEach(function (file) {\n          if (allowedFiles[file]) {\n            files.push([allowedFiles[file], Path.join(configDir, file)]);\n          }\n        });\n      } catch (e) {}\n      return files;\n    }\n  }, []).sort(function (a, b) {\n    return a[0] - b[0];\n  }).map(function (file) {\n    return file[1];\n  });\n};\n\n// Using basic recursion pattern, find all the deferred values and resolve them.\nutil.resolveDeferredConfigs = function (config) {\n  var deferred = [];\n  function _iterate(prop) {\n    // We put the properties we are going to look it in an array to keep the order predictable\n    var propsToSort = [];\n\n    // First step is to put the properties of interest in an array\n    for (var property in prop) {\n      if (Object.hasOwnProperty.call(prop, property) && prop[property] != null) {\n        propsToSort.push(property);\n      }\n    }\n\n    // Second step is to iterate of the elements in a predictable (sorted) order\n    propsToSort.sort().forEach(function (property) {\n      if (prop[property].constructor === Object) {\n        _iterate(prop[property]);\n      } else if (prop[property].constructor === Array) {\n        for (var i = 0; i < prop[property].length; i++) {\n          if (prop[property][i] instanceof DeferredConfig) {\n            deferred.push(prop[property][i].prepare(config, prop[property], i));\n          } else {\n            _iterate(prop[property][i]);\n          }\n        }\n      } else {\n        if (prop[property] instanceof DeferredConfig) {\n          deferred.push(prop[property].prepare(config, prop, property));\n        }\n        // else: Nothing to do. Keep the property how it is.\n      }\n    });\n  }\n\n  _iterate(config);\n  deferred.forEach(function (defer) {\n    defer.resolve();\n  });\n};\n\n/**\n * Parse and return the specified configuration file.\n *\n * If the file exists in the application config directory, it will\n * parse and return it as a JavaScript object.\n *\n * The file extension determines the parser to use.\n *\n * .js = File to run that has a module.exports containing the config object\n * .coffee = File to run that has a module.exports with coffee-script containing the config object\n * .iced = File to run that has a module.exports with iced-coffee-script containing the config object\n * All other supported file types (yaml, toml, json, cson, hjson, json5, properties, xml)\n * are parsed with util.parseString.\n *\n * If the file doesn't exist, a null will be returned.  If the file can't be\n * parsed, an exception will be thrown.\n *\n * This method performs synchronous file operations, and should not be called\n * after synchronous module loading.\n *\n * @protected\n * @method parseFile\n * @param fullFilename {string} The full file path and name\n * @param options { object | undefined } parsing options. Current supported option: skipConfigSources: true|false\n * @return configObject {object|null} The configuration object parsed from the file\n */\nutil.parseFile = function (fullFilename, options) {\n  var t = this,\n    // Initialize\n    configObject = null,\n    fileContent = null,\n    stat = null;\n\n  // Note that all methods here are the Sync versions.  This is appropriate during\n  // module loading (which is a synchronous operation), but not thereafter.\n\n  try {\n    // Try loading the file.\n    fileContent = FileSystem.readFileSync(fullFilename, 'utf-8');\n    fileContent = fileContent.replace(/^\\uFEFF/, '');\n  } catch (e2) {\n    if (e2.code !== 'ENOENT') {\n      throw new Error('Config file ' + fullFilename + ' cannot be read. Error code is: ' + e2.code + '. Error message is: ' + e2.message);\n    }\n    return null; // file doesn't exists\n  }\n\n  // Parse the file based on extension\n  try {\n    // skip if it's a gitcrypt file and CONFIG_SKIP_GITCRYPT is true\n    if (CONFIG_SKIP_GITCRYPT) {\n      if (gitCryptTestRegex.test(fileContent)) {\n        console.error('WARNING: ' + fullFilename + ' is a git-crypt file and CONFIG_SKIP_GITCRYPT is set. skipping.');\n        return null;\n      }\n    }\n    configObject = Parser.parse(fullFilename, fileContent);\n  } catch (e3) {\n    if (gitCryptTestRegex.test(fileContent)) {\n      console.error('ERROR: ' + fullFilename + ' is a git-crypt file and CONFIG_SKIP_GITCRYPT is not set.');\n    }\n    throw new Error(\"Cannot parse config file: '\" + fullFilename + \"': \" + e3);\n  }\n\n  // Keep track of this configuration sources, including empty ones, unless the skipConfigSources flag is set to true in the options\n  var skipConfigSources = util.getOption(options, 'skipConfigSources', false);\n  if (typeof configObject === 'object' && !skipConfigSources) {\n    configSources.push({\n      name: fullFilename,\n      original: fileContent,\n      parsed: configObject\n    });\n  }\n  return configObject;\n};\n\n/**\n * Parse and return the specified string with the specified format.\n *\n * The format determines the parser to use.\n *\n * json = File is parsed using JSON.parse()\n * yaml (or yml) = Parsed with a YAML parser\n * toml = Parsed with a TOML parser\n * cson = Parsed with a CSON parser\n * hjson = Parsed with a HJSON parser\n * json5 = Parsed with a JSON5 parser\n * properties = Parsed with the 'properties' node package\n * xml = Parsed with a XML parser\n *\n * If the file doesn't exist, a null will be returned.  If the file can't be\n * parsed, an exception will be thrown.\n *\n * This method performs synchronous file operations, and should not be called\n * after synchronous module loading.\n *\n * @protected\n * @method parseString\n * @param content {string} The full content\n * @param format {string} The format to be parsed\n * @return {configObject} The configuration object parsed from the string\n */\nutil.parseString = function (content, format) {\n  var parser = Parser.getParser(format);\n  if (typeof parser === 'function') {\n    return parser(null, content);\n  }\n};\n\n/**\n * Attach the Config class prototype to all config objects recursively.\n *\n * <p>\n * This allows you to do anything with CONFIG sub-objects as you can do with\n * the top-level CONFIG object.  It's so you can do this:\n * </p>\n *\n * <pre>\n *   var CUST_CONFIG = require('config').Customer;\n *   CUST_CONFIG.get(...)\n * </pre>\n *\n * @protected\n * @method attachProtoDeep\n * @param toObject\n * @param depth\n * @return toObject\n */\nutil.attachProtoDeep = function (toObject, depth) {\n  if (toObject instanceof RawConfig) {\n    return toObject;\n  }\n\n  // Recursion detection\n  var t = this;\n  depth = depth === null ? DEFAULT_CLONE_DEPTH : depth;\n  if (depth < 0) {\n    return toObject;\n  }\n\n  // Adding Config.prototype methods directly to toObject as hidden properties\n  // because adding to toObject.__proto__ exposes the function in toObject\n  for (var fnName in Config.prototype) {\n    if (!toObject[fnName]) {\n      util.makeHidden(toObject, fnName, Config.prototype[fnName]);\n    }\n  }\n\n  // Add prototypes to sub-objects\n  for (var prop in toObject) {\n    if (util.isObject(toObject[prop])) {\n      util.attachProtoDeep(toObject[prop], depth - 1);\n    }\n  }\n\n  // Return the original object\n  return toObject;\n};\n\n/**\n * Return a deep copy of the specified object.\n *\n * This returns a new object with all elements copied from the specified\n * object.  Deep copies are made of objects and arrays so you can do anything\n * with the returned object without affecting the input object.\n *\n * @protected\n * @method cloneDeep\n * @param parent {object} The original object to copy from\n * @param [depth=20] {Integer} Maximum depth (default 20)\n * @return {object} A new object with the elements copied from the copyFrom object\n *\n * This method is copied from https://github.com/pvorb/node-clone/blob/17eea36140d61d97a9954c53417d0e04a00525d9/clone.js\n *\n * Copyright © 2011-2014 Paul Vorbach and contributors.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the “Software”), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions: The above copyright notice and this permission\n * notice shall be included in all copies or substantial portions of the Software.\n */\nutil.cloneDeep = function cloneDeep(parent, depth, circular, prototype) {\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n  var useBuffer = typeof Buffer != 'undefined';\n  if (typeof circular === 'undefined') circular = true;\n  if (typeof depth === 'undefined') depth = 20;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null) return null;\n    if (depth === 0) return parent;\n    var child;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n    if (Utils.isArray(parent)) {\n      child = [];\n    } else if (Utils.isRegExp(parent)) {\n      child = new RegExp(parent.source, util.getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (Utils.isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = Buffer.alloc(parent.length);\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype === 'undefined') child = Object.create(Object.getPrototypeOf(parent));else child = Object.create(prototype);\n    }\n    if (circular) {\n      var index = allParents.indexOf(parent);\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n    for (var i in parent) {\n      var propDescriptor = Object.getOwnPropertyDescriptor(parent, i);\n      var hasGetter = propDescriptor !== undefined && propDescriptor.get !== undefined;\n      if (hasGetter) {\n        Object.defineProperty(child, i, propDescriptor);\n      } else if (util.isPromise(parent[i])) {\n        child[i] = parent[i];\n      } else {\n        child[i] = _clone(parent[i], depth - 1);\n      }\n    }\n    return child;\n  }\n  return _clone(parent, depth);\n};\n\n/**\n * Set objects given a path as a string list\n *\n * @protected\n * @method setPath\n * @param object {object} - Object to set the property on\n * @param path {array[string]} - Array path to the property\n * @param value {*} - value to set, ignoring null\n */\nutil.setPath = function (object, path, value) {\n  var nextKey = null;\n  if (value === null || path.length === 0) {\n    return;\n  } else if (path.length === 1) {\n    // no more keys to make, so set the value\n    object[path.shift()] = value;\n  } else {\n    nextKey = path.shift();\n    if (!Object.hasOwnProperty.call(object, nextKey)) {\n      object[nextKey] = {};\n    }\n    util.setPath(object[nextKey], path, value);\n  }\n};\n\n/**\n * Create a new object patterned after substitutionMap, where:\n * 1. Terminal string values in substitutionMap are used as keys\n * 2. To look up values in a key-value store, variables\n * 3. And parent keys are created as necessary to retain the structure of substitutionMap.\n *\n * @protected\n * @method substituteDeep\n * @param substitutionMap {object} - an object whose terminal (non-subobject) values are strings\n * @param variables {object[string:value]} - usually process.env, a flat object used to transform\n *      terminal values in a copy of substitutionMap.\n * @returns {object} - deep copy of substitutionMap with only those paths whose terminal values\n *      corresponded to a key in `variables`\n */\nutil.substituteDeep = function (substitutionMap, variables) {\n  var result = {};\n  function _substituteVars(map, vars, pathTo) {\n    for (var prop in map) {\n      var value = map[prop];\n      if (typeof value === 'string') {\n        // We found a leaf variable name\n        if (vars[value] !== undefined && vars[value] !== '') {\n          // if the vars provide a value set the value in the result map\n          util.setPath(result, pathTo.concat(prop), vars[value]);\n        }\n      } else if (util.isObject(value)) {\n        // work on the subtree, giving it a clone of the pathTo\n        if ('__name' in value && '__format' in value && vars[value.__name] !== undefined && vars[value.__name] !== '') {\n          try {\n            var parsedValue = util.parseString(vars[value.__name], value.__format);\n          } catch (err) {\n            err.message = '__format parser error in ' + value.__name + ': ' + err.message;\n            throw err;\n          }\n          util.setPath(result, pathTo.concat(prop), parsedValue);\n        } else {\n          _substituteVars(value, vars, pathTo.concat(prop));\n        }\n      } else {\n        msg = \"Illegal key type for substitution map at \" + pathTo.join('.') + ': ' + typeof value;\n        throw Error(msg);\n      }\n    }\n  }\n  _substituteVars(substitutionMap, variables, []);\n  return result;\n};\n\n/* Map environment variables into the configuration if a mapping file,\n * `custom-environment-variables.EXT` exists.\n *\n * @protected\n * @method getCustomEnvVars\n * @param configDir {string} - the passed configuration directory\n * @param extNames {Array[string]} - acceptable configuration file extension names.\n * @returns {object} - mapped environment variables or {} if there are none\n */\nutil.getCustomEnvVars = function (configDir, extNames) {\n  var result = {};\n  var resolutionIndex = 1;\n  var allowedFiles = {};\n  extNames.forEach(function (extName) {\n    allowedFiles['custom-environment-variables' + '.' + extName] = resolutionIndex++;\n  });\n  var locatedFiles = util.locateMatchingFiles(configDir, allowedFiles);\n  locatedFiles.forEach(function (fullFilename) {\n    var configObj = util.parseFile(fullFilename);\n    if (configObj) {\n      var environmentSubstitutions = util.substituteDeep(configObj, process.env);\n      util.extendDeep(result, environmentSubstitutions);\n    }\n  });\n  return result;\n};\n\n/**\n * Return true if two objects have equal contents.\n *\n * @protected\n * @method equalsDeep\n * @param object1 {object} The object to compare from\n * @param object2 {object} The object to compare with\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {boolean} True if both objects have equivalent contents\n */\nutil.equalsDeep = function (object1, object2, depth) {\n  // Recursion detection\n  var t = this;\n  depth = depth === null ? DEFAULT_CLONE_DEPTH : depth;\n  if (depth < 0) {\n    return {};\n  }\n\n  // Fast comparisons\n  if (!object1 || !object2) {\n    return false;\n  }\n  if (object1 === object2) {\n    return true;\n  }\n  if (typeof object1 != 'object' || typeof object2 != 'object') {\n    return false;\n  }\n\n  // They must have the same keys.  If their length isn't the same\n  // then they're not equal.  If the keys aren't the same, the value\n  // comparisons will fail.\n  if (Object.keys(object1).length != Object.keys(object2).length) {\n    return false;\n  }\n\n  // Compare the values\n  for (var prop in object1) {\n    // Call recursively if an object or array\n    if (object1[prop] && typeof object1[prop] === 'object') {\n      if (!util.equalsDeep(object1[prop], object2[prop], depth - 1)) {\n        return false;\n      }\n    } else {\n      if (object1[prop] !== object2[prop]) {\n        return false;\n      }\n    }\n  }\n\n  // Test passed.\n  return true;\n};\n\n/**\n * Returns an object containing all elements that differ between two objects.\n * <p>\n * This method was designed to be used to create the runtime.json file\n * contents, but can be used to get the diffs between any two Javascript objects.\n * </p>\n * <p>\n * It works best when object2 originated by deep copying object1, then\n * changes were made to object2, and you want an object that would give you\n * the changes made to object1 which resulted in object2.\n * </p>\n *\n * @protected\n * @method diffDeep\n * @param object1 {object} The base object to compare to\n * @param object2 {object} The object to compare with\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {object} A differential object, which if extended onto object1 would\n *                  result in object2.\n */\nutil.diffDeep = function (object1, object2, depth) {\n  // Recursion detection\n  var t = this,\n    diff = {};\n  depth = depth === null ? DEFAULT_CLONE_DEPTH : depth;\n  if (depth < 0) {\n    return {};\n  }\n\n  // Process each element from object2, adding any element that's different\n  // from object 1.\n  for (var parm in object2) {\n    var value1 = object1[parm];\n    var value2 = object2[parm];\n    if (value1 && value2 && util.isObject(value2)) {\n      if (!util.equalsDeep(value1, value2)) {\n        diff[parm] = util.diffDeep(value1, value2, depth - 1);\n      }\n    } else if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (!util.equalsDeep(value1, value2)) {\n        diff[parm] = value2;\n      }\n    } else if (value1 !== value2) {\n      diff[parm] = value2;\n    }\n  }\n\n  // Return the diff object\n  return diff;\n};\n\n/**\n * Extend an object, and any object it contains.\n *\n * This does not replace deep objects, but dives into them\n * replacing individual elements instead.\n *\n * @protected\n * @method extendDeep\n * @param mergeInto {object} The object to merge into\n * @param mergeFrom... {object...} - Any number of objects to merge from\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {object} The altered mergeInto object is returned\n */\nutil.extendDeep = function (mergeInto) {\n  // Initialize\n  var t = this;\n  var vargs = Array.prototype.slice.call(arguments, 1);\n  var depth = vargs.pop();\n  if (typeof depth != 'number') {\n    vargs.push(depth);\n    depth = DEFAULT_CLONE_DEPTH;\n  }\n\n  // Recursion detection\n  if (depth < 0) {\n    return mergeInto;\n  }\n\n  // Cycle through each object to extend\n  vargs.forEach(function (mergeFrom) {\n    // Cycle through each element of the object to merge from\n    for (var prop in mergeFrom) {\n      // save original value in deferred elements\n      var fromIsDeferredFunc = mergeFrom[prop] instanceof DeferredConfig;\n      var isDeferredFunc = mergeInto[prop] instanceof DeferredConfig;\n      if (fromIsDeferredFunc && Object.hasOwnProperty.call(mergeInto, prop)) {\n        mergeFrom[prop]._original = isDeferredFunc ? mergeInto[prop]._original : mergeInto[prop];\n      }\n      // Extend recursively if both elements are objects and target is not really a deferred function\n      if (mergeFrom[prop] instanceof Date) {\n        mergeInto[prop] = mergeFrom[prop];\n      }\n      if (mergeFrom[prop] instanceof RegExp) {\n        mergeInto[prop] = mergeFrom[prop];\n      } else if (util.isObject(mergeInto[prop]) && util.isObject(mergeFrom[prop]) && !isDeferredFunc) {\n        util.extendDeep(mergeInto[prop], mergeFrom[prop], depth - 1);\n      } else if (util.isPromise(mergeFrom[prop])) {\n        mergeInto[prop] = mergeFrom[prop];\n      }\n      // Copy recursively if the mergeFrom element is an object (or array or fn)\n      else if (mergeFrom[prop] && typeof mergeFrom[prop] === 'object') {\n        mergeInto[prop] = util.cloneDeep(mergeFrom[prop], depth - 1);\n      }\n\n      // Copy property descriptor otherwise, preserving accessors\n      else if (Object.getOwnPropertyDescriptor(Object(mergeFrom), prop)) {\n        Object.defineProperty(mergeInto, prop, Object.getOwnPropertyDescriptor(Object(mergeFrom), prop));\n      } else {\n        mergeInto[prop] = mergeFrom[prop];\n      }\n    }\n  });\n\n  // Chain\n  return mergeInto;\n};\n\n/**\n * Is the specified argument a regular javascript object?\n *\n * The argument is an object if it's a JS object, but not an array.\n *\n * @protected\n * @method isObject\n * @param obj {*} An argument of any type.\n * @return {boolean} TRUE if the arg is an object, FALSE if not\n */\nutil.isObject = function (obj) {\n  return obj !== null && typeof obj === 'object' && !Array.isArray(obj);\n};\n\n/**\n * Is the specified argument a javascript promise?\n *\n * @protected\n * @method isPromise\n * @param obj {*} An argument of any type.\n * @returns {boolean}\n */\nutil.isPromise = function (obj) {\n  return Object.prototype.toString.call(obj) === '[object Promise]';\n};\n\n/**\n * <p>Initialize a parameter from the command line or process environment</p>\n *\n * <p>\n * This method looks for the parameter from the command line in the format\n * --PARAMETER=VALUE, then from the process environment, then from the\n * default specified as an argument.\n * </p>\n *\n * @method initParam\n * @param paramName {String} Name of the parameter\n * @param [defaultValue] {Any} Default value of the parameter\n * @return {Any} The found value, or default value\n */\nutil.initParam = function (paramName, defaultValue) {\n  var t = this;\n\n  // Record and return the value\n  var value = util.getCmdLineArg(paramName) || process.env[paramName] || defaultValue;\n  env[paramName] = value;\n  return value;\n};\n\n/**\n * <p>Get Command Line Arguments</p>\n *\n * <p>\n * This method allows you to retrieve the value of the specified command line argument.\n * </p>\n *\n * <p>\n * The argument is case sensitive, and must be of the form '--ARG_NAME=value'\n * </p>\n *\n * @method getCmdLineArg\n * @param searchFor {String} The argument name to search for\n * @return {*} false if the argument was not found, the argument value if found\n */\nutil.getCmdLineArg = function (searchFor) {\n  var cmdLineArgs = process.argv.slice(2, process.argv.length),\n    argName = '--' + searchFor + '=';\n  for (var argvIt = 0; argvIt < cmdLineArgs.length; argvIt++) {\n    if (cmdLineArgs[argvIt].indexOf(argName) === 0) {\n      return cmdLineArgs[argvIt].substr(argName.length);\n    }\n  }\n  return false;\n};\n\n/**\n * <p>Get a Config Environment Variable Value</p>\n *\n * <p>\n * This method returns the value of the specified config environment variable,\n * including any defaults or overrides.\n * </p>\n *\n * @method getEnv\n * @param varName {String} The environment variable name\n * @return {String} The value of the environment variable\n */\nutil.getEnv = function (varName) {\n  return env[varName];\n};\n\n/**\n * Returns a string of flags for regular expression `re`.\n *\n * @param {RegExp} re Regular expression\n * @returns {string} Flags\n */\nutil.getRegExpFlags = function (re) {\n  var flags = '';\n  re.global && (flags += 'g');\n  re.ignoreCase && (flags += 'i');\n  re.multiline && (flags += 'm');\n  return flags;\n};\n\n/**\n * Returns a new deep copy of the current config object, or any part of the config if provided.\n *\n * @param {Object} config The part of the config to copy and serialize. Omit this argument to return the entire config.\n * @returns {Object} The cloned config or part of the config\n */\nutil.toObject = function (config) {\n  return JSON.parse(JSON.stringify(config || this));\n};\n\n// Run strictness checks on NODE_ENV and NODE_APP_INSTANCE and throw an error if there's a problem.\nutil.runStrictnessChecks = function (config) {\n  var sources = config.util.getConfigSources();\n  var sourceFilenames = sources.map(function (src) {\n    return Path.basename(src.name);\n  });\n  NODE_ENV.forEach(function (env) {\n    // Throw an exception if there's no explicit config file for NODE_ENV\n    var anyFilesMatchEnv = sourceFilenames.some(function (filename) {\n      return filename.match(env);\n    });\n    // development is special-cased because it's the default value\n    if (env && env !== 'development' && !anyFilesMatchEnv) {\n      _warnOrThrow(NODE_ENV_VAR_NAME + \" value of '\" + env + \"' did not match any deployment config file names.\");\n    }\n    // Throw if NODE_ENV matches' default' or 'local'\n    if (env === 'default' || env === 'local') {\n      _warnOrThrow(NODE_ENV_VAR_NAME + \" value of '\" + env + \"' is ambiguous.\");\n    }\n  });\n\n  // Throw an exception if there's no explicit config file for NODE_APP_INSTANCE\n  var anyFilesMatchInstance = sourceFilenames.some(function (filename) {\n    return filename.match(APP_INSTANCE);\n  });\n  if (APP_INSTANCE && !anyFilesMatchInstance) {\n    _warnOrThrow(\"NODE_APP_INSTANCE value of '\" + APP_INSTANCE + \"' did not match any instance config file names.\");\n  }\n  function _warnOrThrow(msg) {\n    var beStrict = process.env.NODE_CONFIG_STRICT_MODE;\n    var prefix = beStrict ? 'FATAL: ' : 'WARNING: ';\n    var seeURL = 'See https://github.com/node-config/node-config/wiki/Strict-Mode';\n    console.error(prefix + msg);\n    console.error(prefix + seeURL);\n\n    // Accept 1 and true as truthy values. When set via process.env, Node.js casts them to strings.\n    if ([\"true\", \"1\"].indexOf(beStrict) >= 0) {\n      throw new Error(prefix + msg + ' ' + seeURL);\n    }\n  }\n};\n\n// Helper functions shared accross object members\nfunction _toAbsolutePath(configDir) {\n  if (configDir.indexOf('.') === 0) {\n    return Path.join(process.cwd(), configDir);\n  }\n  return configDir;\n}\n\n// Instantiate and export the configuration\nvar config = module.exports = new Config();\n\n// copy methods to util for backwards compatibility\nutil.stripComments = Parser.stripComments;\nutil.stripYamlComments = Parser.stripYamlComments;\n\n// Produce warnings if the configuration is empty\nvar showWarnings = !util.initParam('SUPPRESS_NO_CONFIG_WARNING');\nif (showWarnings && Object.keys(config).length === 0) {\n  console.error('WARNING: No configurations found in configuration directory:' + CONFIG_DIR);\n  console.error('WARNING: To disable this warning set SUPPRESS_NO_CONFIG_WARNING in the environment.');\n}","map":{"version":3,"names":["DeferredConfig","require","RawConfig","Parser","Utils","Path","FileSystem","DEFAULT_CLONE_DEPTH","CONFIG_DIR","NODE_ENV","APP_INSTANCE","CONFIG_SKIP_GITCRYPT","NODE_ENV_VAR_NAME","NODE_CONFIG_PARSER","env","configSources","checkMutability","gitCryptTestRegex","Config","t","fnName","util","bind","extendDeep","loadFileConfigs","attachProtoDeep","runStrictnessChecks","prototype","getImpl","object","property","elems","Array","isArray","split","name","value","length","undefined","slice","get","Error","initParam","makeImmutable","config","has","setModuleDefaults","moduleName","defaultProperties","moduleConfig","cloneDeep","splice","parsed","setPath","makeHidden","Object","defineProperty","enumerable","Buffer","isBuffer","properties","writable","configurable","keys","i","propertyName","resolve","forEach","item","index","isObject","freeze","Proxy","set","target","message","Reflect","preventExtensions","getConfigSources","getOption","options","optionName","defaultValue","configDir","node_env_var_names","node_env_var_name","dir","join","process","cwd","_toAbsolutePath","runtimeFilename","parserModule","isAbsolute","e","console","warn","log","HOST","HOSTNAME","hostName","OS","hostname","baseNames","concat","firstDomain","push","allowedFiles","resolutionIndex","extNames","getFilesOrder","baseName","extName","locatedFiles","locateMatchingFiles","fullFilename","configObj","parseFile","envConfig","NODE_CONFIG","JSON","parse","error","skipConfigSources","cmdLineConfig","getCmdLineArg","stringify","customEnvVars","getCustomEnvVars","runtimeJson","resolveDeferredConfigs","configDirs","delimiter","reduce","files","readdirSync","file","sort","a","b","map","deferred","_iterate","prop","propsToSort","hasOwnProperty","call","constructor","prepare","defer","configObject","fileContent","stat","readFileSync","replace","e2","code","test","e3","original","parseString","content","format","parser","getParser","toObject","depth","parent","circular","allParents","allChildren","useBuffer","_clone","child","isRegExp","RegExp","source","getRegExpFlags","lastIndex","isDate","Date","getTime","alloc","copy","create","getPrototypeOf","indexOf","propDescriptor","getOwnPropertyDescriptor","hasGetter","isPromise","path","nextKey","shift","substituteDeep","substitutionMap","variables","result","_substituteVars","vars","pathTo","__name","parsedValue","__format","err","msg","environmentSubstitutions","equalsDeep","object1","object2","diffDeep","diff","parm","value1","value2","mergeInto","vargs","arguments","pop","mergeFrom","fromIsDeferredFunc","isDeferredFunc","_original","obj","toString","paramName","searchFor","cmdLineArgs","argv","argName","argvIt","substr","getEnv","varName","re","flags","global","ignoreCase","multiline","sources","sourceFilenames","src","basename","anyFilesMatchEnv","some","filename","match","_warnOrThrow","anyFilesMatchInstance","beStrict","NODE_CONFIG_STRICT_MODE","prefix","seeURL","module","exports","stripComments","stripYamlComments","showWarnings"],"sources":["/data/front/node_modules/config/lib/config.js"],"sourcesContent":["// config.js (c) 2010-2022 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-config\n\n// Dependencies\nvar DeferredConfig = require('../defer').DeferredConfig,\n    RawConfig = require('../raw').RawConfig,\n    Parser = require('../parser'),\n    Utils = require('util'),\n    Path = require('path'),\n    FileSystem = require('fs');\n\n// Static members\nvar DEFAULT_CLONE_DEPTH = 20,\n    CONFIG_DIR, NODE_ENV, APP_INSTANCE,\n    CONFIG_SKIP_GITCRYPT, NODE_ENV_VAR_NAME,\n    NODE_CONFIG_PARSER,\n    env = {},\n    configSources = [],          // Configuration sources - array of {name, original, parsed}\n    checkMutability = true,      // Check for mutability/immutability on first get\n    gitCryptTestRegex = /^.GITCRYPT/; // regular expression to test for gitcrypt files.\n\n/**\n * <p>Application Configurations</p>\n *\n * <p>\n * The config module exports a singleton object representing all\n * configurations for this application deployment.\n * </p>\n *\n * <p>\n * Application configurations are stored in files within the config directory\n * of your application.  The default configuration file is loaded, followed\n * by files specific to the deployment type (development, testing, staging,\n * production, etc.).\n * </p>\n *\n * <p>\n * For example, with the following config/default.yaml file:\n * </p>\n *\n * <pre>\n *   ...\n *   customer:\n *     &nbsp;&nbsp;initialCredit: 500\n *     &nbsp;&nbsp;db:\n *       &nbsp;&nbsp;&nbsp;&nbsp;name: customer\n *       &nbsp;&nbsp;&nbsp;&nbsp;port: 5984\n *   ...\n * </pre>\n *\n * <p>\n * The following code loads the customer section into the CONFIG variable:\n * <p>\n *\n * <pre>\n *   var CONFIG = require('config').customer;\n *   ...\n *   newCustomer.creditLimit = CONFIG.initialCredit;\n *   database.open(CONFIG.db.name, CONFIG.db.port);\n *   ...\n * </pre>\n *\n * @module config\n * @class Config\n */\n\n/**\n * <p>Get the configuration object.</p>\n *\n * <p>\n * The configuration object is a shared singleton object within the application,\n * attained by calling require('config').\n * </p>\n *\n * <p>\n * Usually you'll specify a CONFIG variable at the top of your .js file\n * for file/module scope. If you want the root of the object, you can do this:\n * </p>\n * <pre>\n * var CONFIG = require('config');\n * </pre>\n *\n * <p>\n * Sometimes you only care about a specific sub-object within the CONFIG\n * object.  In that case you could do this at the top of your file:\n * </p>\n * <pre>\n * var CONFIG = require('config').customer;\n * or\n * var CUSTOMER_CONFIG = require('config').customer;\n * </pre>\n *\n * <script type=\"text/javascript\">\n *   document.getElementById(\"showProtected\").style.display = \"block\";\n * </script>\n *\n * @method constructor\n * @return CONFIG {object} - The top level configuration object\n */\nvar Config = function() {\n  var t = this;\n\n  // Bind all utility functions to this\n  for (var fnName in util) {\n    if (typeof util[fnName] === 'function') {\n      util[fnName] = util[fnName].bind(t);\n    }\n  }\n\n  // Merge configurations into this\n  util.extendDeep(t, util.loadFileConfigs());\n  util.attachProtoDeep(t);\n\n  // Perform strictness checks and possibly throw an exception.\n  util.runStrictnessChecks(t);\n};\n\n/**\n * Utilities are under the util namespace vs. at the top level\n */\nvar util = Config.prototype.util = {};\n\n/**\n * Underlying get mechanism\n *\n * @private\n * @method getImpl\n * @param object {object} - Object to get the property for\n * @param property {string|string[]} - The property name to get (as an array or '.' delimited string)\n * @return value {*} - Property value, including undefined if not defined.\n */\nvar getImpl= function(object, property) {\n  var t = this,\n      elems = Array.isArray(property) ? property : property.split('.'),\n      name = elems[0],\n      value = object[name];\n  if (elems.length <= 1) {\n    return value;\n  }\n  // Note that typeof null === 'object'\n  if (value === null || typeof value !== 'object') {\n    return undefined;\n  }\n  return getImpl(value, elems.slice(1));\n};\n\n/**\n * <p>Get a configuration value</p>\n *\n * <p>\n * This will return the specified property value, throwing an exception if the\n * configuration isn't defined.  It is used to assure configurations are defined\n * before being used, and to prevent typos.\n * </p>\n *\n * @method get\n * @param property {string} - The configuration property to get. Can include '.' sub-properties.\n * @return value {*} - The property value\n */\nConfig.prototype.get = function(property) {\n  if(property === null || property === undefined){\n    throw new Error(\"Calling config.get with null or undefined argument\");\n  }\n\n  // Make configurations immutable after first get (unless disabled)\n  if (checkMutability) {\n    if (!util.initParam('ALLOW_CONFIG_MUTATIONS', false)) {\n      util.makeImmutable(config);\n    }\n    checkMutability = false;\n  }\n  var t = this,\n      value = getImpl(t, property);\n\n  // Produce an exception if the property doesn't exist\n  if (value === undefined) {\n    throw new Error('Configuration property \"' + property + '\" is not defined');\n  }\n\n  // Return the value\n  return value;\n};\n\n/**\n * Test that a configuration parameter exists\n *\n * <pre>\n *    var config = require('config');\n *    if (config.has('customer.dbName')) {\n *      console.log('Customer database name: ' + config.customer.dbName);\n *    }\n * </pre>\n *\n * @method has\n * @param property {string} - The configuration property to test. Can include '.' sub-properties.\n * @return isPresent {boolean} - True if the property is defined, false if not defined.\n */\nConfig.prototype.has = function(property) {\n  // While get() throws an exception for undefined input, has() is designed to test validity, so false is appropriate\n  if(property === null || property === undefined){\n    return false;\n  }\n  var t = this;\n  return (getImpl(t, property) !== undefined);\n};\n\n/**\n * <p>\n * Set default configurations for a node.js module.\n * </p>\n *\n * <p>\n * This allows module developers to attach their configurations onto the\n * default configuration object so they can be configured by the consumers\n * of the module.\n * </p>\n *\n * <p>Using the function within your module:</p>\n * <pre>\n *   var CONFIG = require(\"config\");\n *   CONFIG.util.setModuleDefaults(\"MyModule\", {\n *   &nbsp;&nbsp;templateName: \"t-50\",\n *   &nbsp;&nbsp;colorScheme: \"green\"\n *   });\n * <br>\n *   // Template name may be overridden by application config files\n *   console.log(\"Template: \" + CONFIG.MyModule.templateName);\n * </pre>\n *\n * <p>\n * The above example results in a \"MyModule\" element of the configuration\n * object, containing an object with the specified default values.\n * </p>\n *\n * @method setModuleDefaults\n * @param moduleName {string} - Name of your module.\n * @param defaultProperties {object} - The default module configuration.\n * @return moduleConfig {object} - The module level configuration object.\n */\nutil.setModuleDefaults = function (moduleName, defaultProperties) {\n\n  // Copy the properties into a new object\n  var t = this,\n    moduleConfig = util.cloneDeep(defaultProperties);\n\n  // Set module defaults into the first sources element\n  if (configSources.length === 0 || configSources[0].name !== 'Module Defaults') {\n    configSources.splice(0, 0, {\n      name: 'Module Defaults',\n      parsed: {}\n    });\n  }\n  util.setPath(configSources[0].parsed, moduleName.split('.'), {});\n  util.extendDeep(getImpl(configSources[0].parsed, moduleName), defaultProperties);\n\n  // Create a top level config for this module if it doesn't exist\n  util.setPath(t, moduleName.split('.'), getImpl(t, moduleName) || {});\n\n  // Extend local configurations into the module config\n  util.extendDeep(moduleConfig, getImpl(t, moduleName));\n\n  // Merge the extended configs without replacing the original\n  util.extendDeep(getImpl(t, moduleName), moduleConfig);\n\n  // reset the mutability check for \"config.get\" method.\n  // we are not making t[moduleName] immutable immediately,\n  // since there might be more modifications before the first config.get\n  if (!util.initParam('ALLOW_CONFIG_MUTATIONS', false)) {\n    checkMutability = true;\n  }\n\n  // Attach handlers & watchers onto the module config object\n  return util.attachProtoDeep(getImpl(t, moduleName));\n};\n\n/**\n * <p>Make a configuration property hidden so it doesn't appear when enumerating\n * elements of the object.</p>\n *\n * <p>\n * The property still exists and can be read from and written to, but it won't\n * show up in for ... in loops, Object.keys(), or JSON.stringify() type methods.\n * </p>\n *\n * <p>\n * If the property already exists, it will be made hidden.  Otherwise it will\n * be created as a hidden property with the specified value.\n * </p>\n *\n * <p><i>\n * This method was built for hiding configuration values, but it can be applied\n * to <u>any</u> javascript object.\n * </i></p>\n *\n * <p>Example:</p>\n * <pre>\n *   var CONFIG = require('config');\n *   ...\n *\n *   // Hide the Amazon S3 credentials\n *   CONFIG.util.makeHidden(CONFIG.amazonS3, 'access_id');\n *   CONFIG.util.makeHidden(CONFIG.amazonS3, 'secret_key');\n * </pre>\n *\n * @method makeHidden\n * @param object {object} - The object to make a hidden property into.\n * @param property {string} - The name of the property to make hidden.\n * @param value {*} - (optional) Set the property value to this (otherwise leave alone)\n * @return object {object} - The original object is returned - for chaining.\n */\nutil.makeHidden = function(object, property, value) {\n\n  // If the new value isn't specified, just mark the property as hidden\n  if (typeof value === 'undefined') {\n    Object.defineProperty(object, property, {\n      enumerable : false\n    });\n  }\n  // Otherwise set the value and mark it as hidden\n  else {\n    Object.defineProperty(object, property, {\n      value      : value,\n      enumerable : false\n    });\n  }\n\n  return object;\n}\n\n/**\n * <p>Make a javascript object property immutable (assuring it cannot be changed\n * from the current value).</p>\n * <p>\n * If the specified property is an object, all attributes of that object are\n * made immutable, including properties of contained objects, recursively.\n * If a property name isn't supplied, all properties of the object are made\n * immutable.\n * </p>\n * <p>\n *\n * </p>\n * <p>\n * New properties can be added to the object and those properties will not be\n * immutable unless this method is called on those new properties.\n * </p>\n * <p>\n * This operation cannot be undone.\n * </p>\n *\n * <p>Example:</p>\n * <pre>\n *   var config = require('config');\n *   var myObject = {hello:'world'};\n *   config.util.makeImmutable(myObject);\n * </pre>\n *\n * @method makeImmutable\n * @param object {object} - The object to specify immutable properties for\n * @param [property] {string | [string]} - The name of the property (or array of names) to make immutable.\n *        If not provided, all owned properties of the object are made immutable.\n * @param [value] {* | [*]} - Property value (or array of values) to set\n *        the property to before making immutable. Only used when setting a single\n *        property. Retained for backward compatibility.\n * @return object {object} - The original object is returned - for chaining.\n */\nutil.makeImmutable = function(object, property, value) {\n  if (Buffer.isBuffer(object)) {\n    return object;\n  }\n  var properties = null;\n\n  // Backwards compatibility mode where property/value can be specified\n  if (typeof property === 'string') {\n    return Object.defineProperty(object, property, {\n      value : (typeof value === 'undefined') ? object[property] : value,\n      writable : false,\n      configurable: false\n    });\n  }\n\n  // Get the list of properties to work with\n  if (Array.isArray(property)) {\n    properties = property;\n  }\n  else {\n    properties = Object.keys(object);\n  }\n\n  // Process each property\n  for (var i = 0; i < properties.length; i++) {\n    var propertyName = properties[i],\n        value = object[propertyName];\n\n    if (value instanceof RawConfig) {\n      Object.defineProperty(object, propertyName, {\n        value: value.resolve(),\n        writable: false,\n        configurable: false\n      });\n    } else if (Array.isArray(value)) {\n      // Ensure object items of this array are also immutable.\n      value.forEach((item, index) => { if (util.isObject(item) || Array.isArray(item)) util.makeImmutable(item) })\n\n      Object.defineProperty(object, propertyName, {\n        value: Object.freeze(value)\n      });\n    } else {\n      // Call recursively if an object.\n      if (util.isObject(value)) {\n        // Create a proxy, to capture user updates of configuration options, and throw an exception for awareness, as per:\n        // https://github.com/lorenwest/node-config/issues/514\n        value = new Proxy(util.makeImmutable(value), {\n          set (target, name) {\n            const message = (Reflect.has(target, name) ? 'update' : 'add');\n            // Notify the user.\n            throw Error(`Can not ${message} runtime configuration property: \"${name}\". Configuration objects are immutable unless ALLOW_CONFIG_MUTATIONS is set.`)\n          }\n        })\n      }\n\n      Object.defineProperty(object, propertyName, {\n        value: value,\n        writable : false,\n        configurable: false\n      });\n\n      // Ensure new properties can not be added, as per:\n      // https://github.com/lorenwest/node-config/issues/505\n      Object.preventExtensions(object[propertyName])\n    }\n  }\n\n  return object;\n};\n\n/**\n * Return the sources for the configurations\n *\n * <p>\n * All sources for configurations are stored in an array of objects containing\n * the source name (usually the filename), the original source (as a string),\n * and the parsed source as an object.\n * </p>\n *\n * @method getConfigSources\n * @return configSources {Array[Object]} - An array of objects containing\n *    name, original, and parsed elements\n */\nutil.getConfigSources = function() {\n  var t = this;\n  return configSources.slice(0);\n};\n\n/**\n * Looks into an options object for a specific attribute\n *\n * <p>\n * This method looks into the options object, and if an attribute is defined, returns it,\n * and if not, returns the default value\n * </p>\n *\n * @method getOption\n * @param options {Object | undefined} the options object\n * @param optionName {string} the attribute name to look for\n * @param defaultValue { any } the default in case the options object is empty, or the attribute does not exist.\n * @return options[optionName] if defined, defaultValue if not.\n */\nutil.getOption = function(options, optionName, defaultValue) {\n  if (options !== undefined && options[optionName] !== undefined){\n    return options[optionName];\n  } else {\n    return defaultValue;\n  }\n};\n\n\n/**\n * Load the individual file configurations.\n *\n * <p>\n * This method builds a map of filename to the configuration object defined\n * by the file.  The search order is:\n * </p>\n *\n * <pre>\n *   default.EXT\n *   (deployment).EXT\n *   (hostname).EXT\n *   (hostname)-(deployment).EXT\n *   local.EXT\n *   local-(deployment).EXT\n *   runtime.json\n * </pre>\n *\n * <p>\n * EXT can be yml, yaml, coffee, iced, json, cson or js signifying the file type.\n * yaml (and yml) is in YAML format, coffee is a coffee-script, iced is iced-coffee-script,\n * json is in JSON format, cson is in CSON format, properties is in .properties format\n * (http://en.wikipedia.org/wiki/.properties), and js is a javascript executable file that is\n * require()'d with module.exports being the config object.\n * </p>\n *\n * <p>\n * hostname is the $HOST environment variable (or --HOST command line parameter)\n * if set, otherwise the $HOSTNAME environment variable (or --HOSTNAME command\n * line parameter) if set, otherwise the hostname found from\n * require('os').hostname().\n * </p>\n *\n * <p>\n * Once a hostname is found, everything from the first period ('.') onwards\n * is removed. For example, abc.example.com becomes abc\n * </p>\n *\n * <p>\n * (deployment) is the deployment type, found in the $NODE_ENV environment\n * variable (which can be overridden by using $NODE_CONFIG_ENV\n * environment variable). Defaults to 'development'.\n * </p>\n *\n * <p>\n * The runtime.json file contains configuration changes made at runtime either\n * manually, or by the application setting a configuration value.\n * </p>\n *\n * <p>\n * If the $NODE_APP_INSTANCE environment variable (or --NODE_APP_INSTANCE\n * command line parameter) is set, then files with this appendage will be loaded.\n * See the Multiple Application Instances section of the main documentation page\n * for more information.\n * </p>\n *\n * @protected\n * @method loadFileConfigs\n * @param configDir { string | null } the path to the directory containing the configurations to load\n * @param options { object | undefined } parsing options. Current supported option: skipConfigSources: true|false\n * @return config {Object} The configuration object\n */\nutil.loadFileConfigs = function(configDir, options) {\n\n  // Initialize\n  var t = this,\n      config = {};\n\n  // Specify variables that can be used to define the environment\n  var node_env_var_names = ['NODE_CONFIG_ENV', 'NODE_ENV'];\n\n  // Loop through the variables to try and set environment\n  for (const node_env_var_name of node_env_var_names) {\n    NODE_ENV = util.initParam(node_env_var_name);\n    if (!!NODE_ENV) {\n      NODE_ENV_VAR_NAME = node_env_var_name;\n      break;\n    }\n  }\n\n  // If we haven't successfully set the environment using the variables, we'll default it\n  if (!NODE_ENV) {\n    NODE_ENV = 'development';\n  }\n\n  node_env_var_names.forEach(node_env_var_name => {\n    env[node_env_var_name] = NODE_ENV;\n  });\n\n  // Split files name, for loading multiple files.\n  NODE_ENV = NODE_ENV.split(',');\n\n  var dir = configDir || util.initParam('NODE_CONFIG_DIR', Path.join( process.cwd(), 'config') );\n  dir = _toAbsolutePath(dir);\n\n  APP_INSTANCE = util.initParam('NODE_APP_INSTANCE');\n  CONFIG_SKIP_GITCRYPT = util.initParam('CONFIG_SKIP_GITCRYPT');\n\n  // This is for backward compatibility\n  var runtimeFilename = util.initParam('NODE_CONFIG_RUNTIME_JSON', Path.join(dir , 'runtime.json') );\n\n  NODE_CONFIG_PARSER = util.initParam('NODE_CONFIG_PARSER');\n  if (NODE_CONFIG_PARSER) {\n    try {\n      var parserModule = Path.isAbsolute(NODE_CONFIG_PARSER)\n        ? NODE_CONFIG_PARSER\n        : Path.join(dir, NODE_CONFIG_PARSER);\n      Parser = require(parserModule);\n    }\n    catch (e) {\n      console.warn('Failed to load config parser from ' + NODE_CONFIG_PARSER);\n      console.log(e);\n    }\n  }\n\n  var HOST = util.initParam('HOST');\n  var HOSTNAME = util.initParam('HOSTNAME');\n\n  // Determine the host name from the OS module, $HOST, or $HOSTNAME\n  // Remove any . appendages, and default to null if not set\n  try {\n    var hostName = HOST || HOSTNAME;\n\n    if (!hostName) {\n        var OS = require('os');\n        hostName = OS.hostname();\n    }\n  } catch (e) {\n    hostName = '';\n  }\n\n  // Store the hostname that won.\n  env.HOSTNAME = hostName;\n\n  // Read each file in turn\n  var baseNames = ['default'].concat(NODE_ENV);\n\n  // #236: Also add full hostname when they are different.\n  if (hostName) {\n    var firstDomain = hostName.split('.')[0];\n\n    NODE_ENV.forEach(function(env) {\n      // Backward compatibility\n      baseNames.push(firstDomain, firstDomain + '-' + env);\n\n      // Add full hostname when it is not the same\n      if (hostName !== firstDomain) {\n        baseNames.push(hostName, hostName + '-' + env);\n      }\n    });\n  }\n\n  NODE_ENV.forEach(function(env) {\n    baseNames.push('local', 'local-' + env);\n  });\n\n  var allowedFiles = {};\n  var resolutionIndex = 1;\n  var extNames = Parser.getFilesOrder();\n  baseNames.forEach(function(baseName) {\n    extNames.forEach(function(extName) {\n      allowedFiles[baseName + '.' + extName] = resolutionIndex++;\n      if (APP_INSTANCE) {\n        allowedFiles[baseName + '-' + APP_INSTANCE + '.' + extName] = resolutionIndex++;\n      }\n    });\n  });\n\n  var locatedFiles = util.locateMatchingFiles(dir, allowedFiles);\n  locatedFiles.forEach(function(fullFilename) {\n    var configObj = util.parseFile(fullFilename, options);\n    if (configObj) {\n      util.extendDeep(config, configObj);\n    }\n  });\n\n  // Override configurations from the $NODE_CONFIG environment variable\n  // NODE_CONFIG only applies to the base config\n  if (!configDir) {\n    var envConfig = {};\n\n    CONFIG_DIR = dir;\n\n    if (process.env.NODE_CONFIG) {\n      try {\n        envConfig = JSON.parse(process.env.NODE_CONFIG);\n      } catch(e) {\n        console.error('The $NODE_CONFIG environment variable is malformed JSON');\n      }\n      util.extendDeep(config, envConfig);\n      var skipConfigSources = util.getOption(options,'skipConfigSources', false);\n      if (!skipConfigSources){\n        configSources.push({\n          name: \"$NODE_CONFIG\",\n          parsed: envConfig,\n        });\n      }\n    }\n\n    // Override configurations from the --NODE_CONFIG command line\n    var cmdLineConfig = util.getCmdLineArg('NODE_CONFIG');\n    if (cmdLineConfig) {\n      try {\n        cmdLineConfig = JSON.parse(cmdLineConfig);\n      } catch(e) {\n        console.error('The --NODE_CONFIG={json} command line argument is malformed JSON');\n      }\n      util.extendDeep(config, cmdLineConfig);\n      var skipConfigSources = util.getOption(options,'skipConfigSources', false);\n      if (!skipConfigSources){\n        configSources.push({\n          name: \"--NODE_CONFIG argument\",\n          parsed: cmdLineConfig,\n        });\n      }\n    }\n\n    // Place the mixed NODE_CONFIG into the environment\n    env['NODE_CONFIG'] = JSON.stringify(util.extendDeep(envConfig, cmdLineConfig, {}));\n  }\n\n  // Override with environment variables if there is a custom-environment-variables.EXT mapping file\n  var customEnvVars = util.getCustomEnvVars(dir, extNames);\n  util.extendDeep(config, customEnvVars);\n\n  // Extend the original config with the contents of runtime.json (backwards compatibility)\n  var runtimeJson = util.parseFile(runtimeFilename) || {};\n  util.extendDeep(config, runtimeJson);\n\n  util.resolveDeferredConfigs(config);\n\n  // Return the configuration object\n  return config;\n};\n\n/**\n * Return a list of fullFilenames who exists in allowedFiles\n * Ordered according to allowedFiles argument specifications\n *\n * @protected\n * @method locateMatchingFiles\n * @param configDirs {string}   the config dir, or multiple dirs separated by a column (:)\n * @param allowedFiles {object} an object. keys and supported filenames\n *                              and values are the position in the resolution order\n * @returns {string[]}          fullFilenames - path + filename\n */\nutil.locateMatchingFiles = function(configDirs, allowedFiles) {\n  return configDirs.split(Path.delimiter)\n    .reduce(function(files, configDir) {\n      if (configDir) {\n        configDir = _toAbsolutePath(configDir);\n        try {\n          FileSystem.readdirSync(configDir).forEach(function(file) {\n            if (allowedFiles[file]) {\n              files.push([allowedFiles[file], Path.join(configDir, file)]);\n            }\n          });\n        }\n        catch(e) {}\n        return files;\n      }\n    }, [])\n    .sort(function(a, b) { return a[0] - b[0]; })\n    .map(function(file) { return file[1]; });\n};\n\n// Using basic recursion pattern, find all the deferred values and resolve them.\nutil.resolveDeferredConfigs = function (config) {\n  var deferred = [];\n\n  function _iterate (prop) {\n\n    // We put the properties we are going to look it in an array to keep the order predictable\n    var propsToSort = [];\n\n    // First step is to put the properties of interest in an array\n    for (var property in prop) {\n      if (Object.hasOwnProperty.call(prop, property) && prop[property] != null) {\n        propsToSort.push(property);\n      }\n    }\n\n    // Second step is to iterate of the elements in a predictable (sorted) order\n    propsToSort.sort().forEach(function (property) {\n      if (prop[property].constructor === Object) {\n        _iterate(prop[property]);\n      } else if (prop[property].constructor === Array) {\n        for (var i = 0; i < prop[property].length; i++) {\n          if (prop[property][i] instanceof DeferredConfig) {\n            deferred.push(prop[property][i].prepare(config, prop[property], i));\n          }\n          else {\n            _iterate(prop[property][i]);\n          }\n        }\n      } else {\n        if (prop[property] instanceof DeferredConfig) {\n          deferred.push(prop[property].prepare(config, prop, property));\n        }\n        // else: Nothing to do. Keep the property how it is.\n      }\n    });\n  }\n\n  _iterate(config);\n\n  deferred.forEach(function (defer) { defer.resolve(); });\n};\n\n/**\n * Parse and return the specified configuration file.\n *\n * If the file exists in the application config directory, it will\n * parse and return it as a JavaScript object.\n *\n * The file extension determines the parser to use.\n *\n * .js = File to run that has a module.exports containing the config object\n * .coffee = File to run that has a module.exports with coffee-script containing the config object\n * .iced = File to run that has a module.exports with iced-coffee-script containing the config object\n * All other supported file types (yaml, toml, json, cson, hjson, json5, properties, xml)\n * are parsed with util.parseString.\n *\n * If the file doesn't exist, a null will be returned.  If the file can't be\n * parsed, an exception will be thrown.\n *\n * This method performs synchronous file operations, and should not be called\n * after synchronous module loading.\n *\n * @protected\n * @method parseFile\n * @param fullFilename {string} The full file path and name\n * @param options { object | undefined } parsing options. Current supported option: skipConfigSources: true|false\n * @return configObject {object|null} The configuration object parsed from the file\n */\nutil.parseFile = function(fullFilename, options) {\n  var t = this,  // Initialize\n      configObject = null,\n      fileContent = null,\n      stat = null;\n\n  // Note that all methods here are the Sync versions.  This is appropriate during\n  // module loading (which is a synchronous operation), but not thereafter.\n\n  try {\n    // Try loading the file.\n    fileContent = FileSystem.readFileSync(fullFilename, 'utf-8');\n    fileContent = fileContent.replace(/^\\uFEFF/, '');\n  }\n  catch (e2) {\n    if (e2.code !== 'ENOENT') {\n      throw new Error('Config file ' + fullFilename + ' cannot be read. Error code is: '+e2.code\n                        +'. Error message is: '+e2.message);\n    }\n    return null;  // file doesn't exists\n  }\n\n  // Parse the file based on extension\n  try {\n\n    // skip if it's a gitcrypt file and CONFIG_SKIP_GITCRYPT is true\n    if (CONFIG_SKIP_GITCRYPT) {\n      if (gitCryptTestRegex.test(fileContent)) {\n        console.error('WARNING: ' + fullFilename + ' is a git-crypt file and CONFIG_SKIP_GITCRYPT is set. skipping.');\n        return null;\n      }\n    }\n\n    configObject = Parser.parse(fullFilename, fileContent);\n  }\n  catch (e3) {\n    if (gitCryptTestRegex.test(fileContent)) {\n      console.error('ERROR: ' + fullFilename + ' is a git-crypt file and CONFIG_SKIP_GITCRYPT is not set.');\n    }\n    throw new Error(\"Cannot parse config file: '\" + fullFilename + \"': \" + e3);\n  }\n\n  // Keep track of this configuration sources, including empty ones, unless the skipConfigSources flag is set to true in the options\n  var skipConfigSources = util.getOption(options,'skipConfigSources', false);\n  if (typeof configObject === 'object' && !skipConfigSources) {\n    configSources.push({\n      name: fullFilename,\n      original: fileContent,\n      parsed: configObject,\n    });\n  }\n\n  return configObject;\n};\n\n/**\n * Parse and return the specified string with the specified format.\n *\n * The format determines the parser to use.\n *\n * json = File is parsed using JSON.parse()\n * yaml (or yml) = Parsed with a YAML parser\n * toml = Parsed with a TOML parser\n * cson = Parsed with a CSON parser\n * hjson = Parsed with a HJSON parser\n * json5 = Parsed with a JSON5 parser\n * properties = Parsed with the 'properties' node package\n * xml = Parsed with a XML parser\n *\n * If the file doesn't exist, a null will be returned.  If the file can't be\n * parsed, an exception will be thrown.\n *\n * This method performs synchronous file operations, and should not be called\n * after synchronous module loading.\n *\n * @protected\n * @method parseString\n * @param content {string} The full content\n * @param format {string} The format to be parsed\n * @return {configObject} The configuration object parsed from the string\n */\nutil.parseString = function (content, format) {\n  var parser = Parser.getParser(format);\n  if (typeof parser === 'function') {\n    return parser(null, content);\n  }\n};\n\n/**\n * Attach the Config class prototype to all config objects recursively.\n *\n * <p>\n * This allows you to do anything with CONFIG sub-objects as you can do with\n * the top-level CONFIG object.  It's so you can do this:\n * </p>\n *\n * <pre>\n *   var CUST_CONFIG = require('config').Customer;\n *   CUST_CONFIG.get(...)\n * </pre>\n *\n * @protected\n * @method attachProtoDeep\n * @param toObject\n * @param depth\n * @return toObject\n */\nutil.attachProtoDeep = function(toObject, depth) {\n  if (toObject instanceof RawConfig) {\n    return toObject;\n  }\n\n  // Recursion detection\n  var t = this;\n  depth = (depth === null ? DEFAULT_CLONE_DEPTH : depth);\n  if (depth < 0) {\n    return toObject;\n  }\n\n  // Adding Config.prototype methods directly to toObject as hidden properties\n  // because adding to toObject.__proto__ exposes the function in toObject\n  for (var fnName in Config.prototype) {\n    if (!toObject[fnName]) {\n      util.makeHidden(toObject, fnName, Config.prototype[fnName]);\n    }\n  }\n\n  // Add prototypes to sub-objects\n  for (var prop in toObject) {\n    if (util.isObject(toObject[prop])) {\n      util.attachProtoDeep(toObject[prop], depth - 1);\n    }\n  }\n\n  // Return the original object\n  return toObject;\n};\n\n/**\n * Return a deep copy of the specified object.\n *\n * This returns a new object with all elements copied from the specified\n * object.  Deep copies are made of objects and arrays so you can do anything\n * with the returned object without affecting the input object.\n *\n * @protected\n * @method cloneDeep\n * @param parent {object} The original object to copy from\n * @param [depth=20] {Integer} Maximum depth (default 20)\n * @return {object} A new object with the elements copied from the copyFrom object\n *\n * This method is copied from https://github.com/pvorb/node-clone/blob/17eea36140d61d97a9954c53417d0e04a00525d9/clone.js\n *\n * Copyright © 2011-2014 Paul Vorbach and contributors.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the “Software”), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions: The above copyright notice and this permission\n * notice shall be included in all copies or substantial portions of the Software.\n */\nutil.cloneDeep = function cloneDeep(parent, depth, circular, prototype) {\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular === 'undefined')\n    circular = true;\n\n  if (typeof depth === 'undefined')\n    depth = 20;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (Utils.isArray(parent)) {\n      child = [];\n    } else if (Utils.isRegExp(parent)) {\n      child = new RegExp(parent.source, util.getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (Utils.isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = Buffer.alloc(parent.length);\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype === 'undefined') child = Object.create(Object.getPrototypeOf(parent));\n      else child = Object.create(prototype);\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var propDescriptor  = Object.getOwnPropertyDescriptor(parent,i);\n      var hasGetter = ((propDescriptor !== undefined) && (propDescriptor.get !== undefined));\n\n      if (hasGetter){\n        Object.defineProperty(child,i,propDescriptor);\n      } else if (util.isPromise(parent[i])) {\n        child[i] = parent[i];\n      } else {\n        child[i] = _clone(parent[i], depth - 1);\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n};\n\n/**\n * Set objects given a path as a string list\n *\n * @protected\n * @method setPath\n * @param object {object} - Object to set the property on\n * @param path {array[string]} - Array path to the property\n * @param value {*} - value to set, ignoring null\n */\nutil.setPath = function (object, path, value) {\n  var nextKey = null;\n  if (value === null || path.length === 0) {\n    return;\n  }\n  else if (path.length === 1) { // no more keys to make, so set the value\n    object[path.shift()] = value;\n  }\n  else {\n    nextKey = path.shift();\n    if (!Object.hasOwnProperty.call(object, nextKey)) {\n      object[nextKey] = {};\n    }\n    util.setPath(object[nextKey], path, value);\n  }\n};\n\n/**\n * Create a new object patterned after substitutionMap, where:\n * 1. Terminal string values in substitutionMap are used as keys\n * 2. To look up values in a key-value store, variables\n * 3. And parent keys are created as necessary to retain the structure of substitutionMap.\n *\n * @protected\n * @method substituteDeep\n * @param substitutionMap {object} - an object whose terminal (non-subobject) values are strings\n * @param variables {object[string:value]} - usually process.env, a flat object used to transform\n *      terminal values in a copy of substitutionMap.\n * @returns {object} - deep copy of substitutionMap with only those paths whose terminal values\n *      corresponded to a key in `variables`\n */\nutil.substituteDeep = function (substitutionMap, variables) {\n  var result = {};\n\n  function _substituteVars(map, vars, pathTo) {\n    for (var prop in map) {\n      var value = map[prop];\n      if (typeof(value) === 'string') { // We found a leaf variable name\n        if (vars[value] !== undefined && vars[value] !== '') { // if the vars provide a value set the value in the result map\n          util.setPath(result, pathTo.concat(prop), vars[value]);\n        }\n      }\n      else if (util.isObject(value)) { // work on the subtree, giving it a clone of the pathTo\n        if ('__name' in value && '__format' in value && vars[value.__name] !== undefined && vars[value.__name] !== '') {\n          try {\n            var parsedValue = util.parseString(vars[value.__name], value.__format);\n          } catch(err) {\n            err.message = '__format parser error in ' + value.__name + ': ' + err.message;\n            throw err;\n          }\n          util.setPath(result, pathTo.concat(prop), parsedValue);\n        } else {\n          _substituteVars(value, vars, pathTo.concat(prop));\n        }\n      }\n      else {\n        msg = \"Illegal key type for substitution map at \" + pathTo.join('.') + ': ' + typeof(value);\n        throw Error(msg);\n      }\n    }\n  }\n\n  _substituteVars(substitutionMap, variables, []);\n  return result;\n\n};\n\n/* Map environment variables into the configuration if a mapping file,\n * `custom-environment-variables.EXT` exists.\n *\n * @protected\n * @method getCustomEnvVars\n * @param configDir {string} - the passed configuration directory\n * @param extNames {Array[string]} - acceptable configuration file extension names.\n * @returns {object} - mapped environment variables or {} if there are none\n */\nutil.getCustomEnvVars = function (configDir, extNames) {\n  var result = {};\n  var resolutionIndex = 1;\n  var allowedFiles = {};\n  extNames.forEach(function (extName) {\n    allowedFiles['custom-environment-variables' + '.' + extName] = resolutionIndex++;\n  });\n  var locatedFiles = util.locateMatchingFiles(configDir, allowedFiles);\n  locatedFiles.forEach(function (fullFilename) {\n    var configObj = util.parseFile(fullFilename);\n    if (configObj) {\n      var environmentSubstitutions = util.substituteDeep(configObj, process.env);\n      util.extendDeep(result, environmentSubstitutions);\n    }\n  });\n  return result;\n};\n\n/**\n * Return true if two objects have equal contents.\n *\n * @protected\n * @method equalsDeep\n * @param object1 {object} The object to compare from\n * @param object2 {object} The object to compare with\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {boolean} True if both objects have equivalent contents\n */\nutil.equalsDeep = function(object1, object2, depth) {\n\n  // Recursion detection\n  var t = this;\n  depth = (depth === null ? DEFAULT_CLONE_DEPTH : depth);\n  if (depth < 0) {\n    return {};\n  }\n\n  // Fast comparisons\n  if (!object1 || !object2) {\n    return false;\n  }\n  if (object1 === object2) {\n    return true;\n  }\n  if (typeof(object1) != 'object' || typeof(object2) != 'object') {\n    return false;\n  }\n\n  // They must have the same keys.  If their length isn't the same\n  // then they're not equal.  If the keys aren't the same, the value\n  // comparisons will fail.\n  if (Object.keys(object1).length != Object.keys(object2).length) {\n    return false;\n  }\n\n  // Compare the values\n  for (var prop in object1) {\n\n    // Call recursively if an object or array\n    if (object1[prop] && typeof(object1[prop]) === 'object') {\n      if (!util.equalsDeep(object1[prop], object2[prop], depth - 1)) {\n        return false;\n      }\n    }\n    else {\n      if (object1[prop] !== object2[prop]) {\n        return false;\n      }\n    }\n  }\n\n  // Test passed.\n  return true;\n};\n\n/**\n * Returns an object containing all elements that differ between two objects.\n * <p>\n * This method was designed to be used to create the runtime.json file\n * contents, but can be used to get the diffs between any two Javascript objects.\n * </p>\n * <p>\n * It works best when object2 originated by deep copying object1, then\n * changes were made to object2, and you want an object that would give you\n * the changes made to object1 which resulted in object2.\n * </p>\n *\n * @protected\n * @method diffDeep\n * @param object1 {object} The base object to compare to\n * @param object2 {object} The object to compare with\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {object} A differential object, which if extended onto object1 would\n *                  result in object2.\n */\nutil.diffDeep = function(object1, object2, depth) {\n\n  // Recursion detection\n  var t = this, diff = {};\n  depth = (depth === null ? DEFAULT_CLONE_DEPTH : depth);\n  if (depth < 0) {\n    return {};\n  }\n\n  // Process each element from object2, adding any element that's different\n  // from object 1.\n  for (var parm in object2) {\n    var value1 = object1[parm];\n    var value2 = object2[parm];\n    if (value1 && value2 && util.isObject(value2)) {\n      if (!(util.equalsDeep(value1, value2))) {\n        diff[parm] = util.diffDeep(value1, value2, depth - 1);\n      }\n    }\n    else if (Array.isArray(value1) && Array.isArray(value2)) {\n      if(!util.equalsDeep(value1, value2)) {\n        diff[parm] = value2;\n      }\n    }\n    else if (value1 !== value2){\n      diff[parm] = value2;\n    }\n  }\n\n  // Return the diff object\n  return diff;\n\n};\n\n/**\n * Extend an object, and any object it contains.\n *\n * This does not replace deep objects, but dives into them\n * replacing individual elements instead.\n *\n * @protected\n * @method extendDeep\n * @param mergeInto {object} The object to merge into\n * @param mergeFrom... {object...} - Any number of objects to merge from\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {object} The altered mergeInto object is returned\n */\nutil.extendDeep = function(mergeInto) {\n\n  // Initialize\n  var t = this;\n  var vargs = Array.prototype.slice.call(arguments, 1);\n  var depth = vargs.pop();\n  if (typeof(depth) != 'number') {\n    vargs.push(depth);\n    depth = DEFAULT_CLONE_DEPTH;\n  }\n\n  // Recursion detection\n  if (depth < 0) {\n    return mergeInto;\n  }\n\n  // Cycle through each object to extend\n  vargs.forEach(function(mergeFrom) {\n\n    // Cycle through each element of the object to merge from\n    for (var prop in mergeFrom) {\n\n      // save original value in deferred elements\n      var fromIsDeferredFunc = mergeFrom[prop] instanceof DeferredConfig;\n      var isDeferredFunc = mergeInto[prop] instanceof DeferredConfig;\n\n      if (fromIsDeferredFunc && Object.hasOwnProperty.call(mergeInto, prop)) {\n        mergeFrom[prop]._original = isDeferredFunc ? mergeInto[prop]._original : mergeInto[prop];\n      }\n      // Extend recursively if both elements are objects and target is not really a deferred function\n      if (mergeFrom[prop] instanceof Date) {\n        mergeInto[prop] = mergeFrom[prop];\n      } if (mergeFrom[prop] instanceof RegExp) {\n        mergeInto[prop] = mergeFrom[prop];\n      } else if (util.isObject(mergeInto[prop]) && util.isObject(mergeFrom[prop]) && !isDeferredFunc) {\n        util.extendDeep(mergeInto[prop], mergeFrom[prop], depth - 1);\n      }\n      else if (util.isPromise(mergeFrom[prop])) {\n        mergeInto[prop] = mergeFrom[prop];\n      }\n      // Copy recursively if the mergeFrom element is an object (or array or fn)\n      else if (mergeFrom[prop] && typeof mergeFrom[prop] === 'object') {\n        mergeInto[prop] = util.cloneDeep(mergeFrom[prop], depth -1);\n      }\n\n      // Copy property descriptor otherwise, preserving accessors\n      else if (Object.getOwnPropertyDescriptor(Object(mergeFrom), prop)){\n          Object.defineProperty(mergeInto, prop, Object.getOwnPropertyDescriptor(Object(mergeFrom), prop));\n      } else {\n          mergeInto[prop] = mergeFrom[prop];\n      }\n    }\n  });\n\n  // Chain\n  return mergeInto;\n\n};\n\n/**\n * Is the specified argument a regular javascript object?\n *\n * The argument is an object if it's a JS object, but not an array.\n *\n * @protected\n * @method isObject\n * @param obj {*} An argument of any type.\n * @return {boolean} TRUE if the arg is an object, FALSE if not\n */\nutil.isObject = function(obj) {\n  return (obj !== null) && (typeof obj === 'object') && !(Array.isArray(obj));\n};\n\n/**\n * Is the specified argument a javascript promise?\n *\n * @protected\n * @method isPromise\n * @param obj {*} An argument of any type.\n * @returns {boolean}\n */\nutil.isPromise = function(obj) {\n  return Object.prototype.toString.call(obj) === '[object Promise]';\n};\n\n/**\n * <p>Initialize a parameter from the command line or process environment</p>\n *\n * <p>\n * This method looks for the parameter from the command line in the format\n * --PARAMETER=VALUE, then from the process environment, then from the\n * default specified as an argument.\n * </p>\n *\n * @method initParam\n * @param paramName {String} Name of the parameter\n * @param [defaultValue] {Any} Default value of the parameter\n * @return {Any} The found value, or default value\n */\nutil.initParam = function (paramName, defaultValue) {\n  var t = this;\n\n  // Record and return the value\n  var value = util.getCmdLineArg(paramName) || process.env[paramName] || defaultValue;\n  env[paramName] = value;\n  return value;\n}\n\n/**\n * <p>Get Command Line Arguments</p>\n *\n * <p>\n * This method allows you to retrieve the value of the specified command line argument.\n * </p>\n *\n * <p>\n * The argument is case sensitive, and must be of the form '--ARG_NAME=value'\n * </p>\n *\n * @method getCmdLineArg\n * @param searchFor {String} The argument name to search for\n * @return {*} false if the argument was not found, the argument value if found\n */\nutil.getCmdLineArg = function (searchFor) {\n    var cmdLineArgs = process.argv.slice(2, process.argv.length),\n        argName = '--' + searchFor + '=';\n\n    for (var argvIt = 0; argvIt < cmdLineArgs.length; argvIt++) {\n      if (cmdLineArgs[argvIt].indexOf(argName) === 0) {\n        return cmdLineArgs[argvIt].substr(argName.length);\n      }\n    }\n\n    return false;\n}\n\n/**\n * <p>Get a Config Environment Variable Value</p>\n *\n * <p>\n * This method returns the value of the specified config environment variable,\n * including any defaults or overrides.\n * </p>\n *\n * @method getEnv\n * @param varName {String} The environment variable name\n * @return {String} The value of the environment variable\n */\nutil.getEnv = function (varName) {\n  return env[varName];\n}\n\n\n\n/**\n * Returns a string of flags for regular expression `re`.\n *\n * @param {RegExp} re Regular expression\n * @returns {string} Flags\n */\nutil.getRegExpFlags = function (re) {\n  var flags = '';\n  re.global && (flags += 'g');\n  re.ignoreCase && (flags += 'i');\n  re.multiline && (flags += 'm');\n  return flags;\n};\n\n/**\n * Returns a new deep copy of the current config object, or any part of the config if provided.\n *\n * @param {Object} config The part of the config to copy and serialize. Omit this argument to return the entire config.\n * @returns {Object} The cloned config or part of the config\n */\nutil.toObject = function(config) {\n  return JSON.parse(JSON.stringify(config || this));\n};\n\n// Run strictness checks on NODE_ENV and NODE_APP_INSTANCE and throw an error if there's a problem.\nutil.runStrictnessChecks = function (config) {\n  var sources = config.util.getConfigSources();\n\n  var sourceFilenames = sources.map(function (src) {\n    return Path.basename(src.name);\n  });\n\n  NODE_ENV.forEach(function(env) {\n    // Throw an exception if there's no explicit config file for NODE_ENV\n    var anyFilesMatchEnv = sourceFilenames.some(function (filename) {\n        return filename.match(env);\n    });\n    // development is special-cased because it's the default value\n    if (env && (env !== 'development') && !anyFilesMatchEnv) {\n      _warnOrThrow(NODE_ENV_VAR_NAME+\" value of '\"+env+\"' did not match any deployment config file names.\");\n    }\n    // Throw if NODE_ENV matches' default' or 'local'\n    if ((env === 'default') || (env === 'local')) {\n      _warnOrThrow(NODE_ENV_VAR_NAME+\" value of '\"+env+\"' is ambiguous.\");\n    }\n  });\n\n  // Throw an exception if there's no explicit config file for NODE_APP_INSTANCE\n  var anyFilesMatchInstance = sourceFilenames.some(function (filename) {\n      return filename.match(APP_INSTANCE);\n  });\n  if (APP_INSTANCE && !anyFilesMatchInstance) {\n    _warnOrThrow(\"NODE_APP_INSTANCE value of '\"+APP_INSTANCE+\"' did not match any instance config file names.\");\n  }\n\n  function _warnOrThrow (msg) {\n    var beStrict = process.env.NODE_CONFIG_STRICT_MODE;\n    var prefix = beStrict ? 'FATAL: ' : 'WARNING: ';\n    var seeURL = 'See https://github.com/node-config/node-config/wiki/Strict-Mode';\n\n    console.error(prefix+msg);\n    console.error(prefix+seeURL);\n\n    // Accept 1 and true as truthy values. When set via process.env, Node.js casts them to strings.\n    if ([\"true\", \"1\"].indexOf(beStrict) >= 0) {\n      throw new Error(prefix+msg+' '+seeURL);\n    }\n  }\n};\n\n// Helper functions shared accross object members\nfunction _toAbsolutePath (configDir) {\n  if (configDir.indexOf('.') === 0) {\n    return Path.join(process.cwd(), configDir);\n  }\n\n  return configDir;\n}\n\n// Instantiate and export the configuration\nvar config = module.exports = new Config();\n\n// copy methods to util for backwards compatibility\nutil.stripComments = Parser.stripComments;\nutil.stripYamlComments = Parser.stripYamlComments;\n\n// Produce warnings if the configuration is empty\nvar showWarnings = !(util.initParam('SUPPRESS_NO_CONFIG_WARNING'));\nif (showWarnings && Object.keys(config).length === 0) {\n  console.error('WARNING: No configurations found in configuration directory:' +CONFIG_DIR);\n  console.error('WARNING: To disable this warning set SUPPRESS_NO_CONFIG_WARNING in the environment.');\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA,IAAIA,cAAc,GAAGC,OAAO,CAAC,UAAU,CAAC,CAACD,cAAc;EACnDE,SAAS,GAAGD,OAAO,CAAC,QAAQ,CAAC,CAACC,SAAS;EACvCC,MAAM,GAAGF,OAAO,CAAC,WAAW,CAAC;EAC7BG,KAAK,GAAGH,OAAO,CAAC,MAAM,CAAC;EACvBI,IAAI,GAAGJ,OAAO,CAAC,MAAM,CAAC;EACtBK,UAAU,GAAGL,OAAO,CAAC,IAAI,CAAC;;AAE9B;AACA,IAAIM,mBAAmB,GAAG,EAAE;EACxBC,UAAU;EAAEC,QAAQ;EAAEC,YAAY;EAClCC,oBAAoB;EAAEC,iBAAiB;EACvCC,kBAAkB;EAClBC,GAAG,GAAG,CAAC,CAAC;EACRC,aAAa,GAAG,EAAE;EAAW;EAC7BC,eAAe,GAAG,IAAI;EAAO;EAC7BC,iBAAiB,GAAG,YAAY,CAAC,CAAC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,MAAM,GAAG,SAAAA,CAAA,EAAW;EACtB,IAAIC,CAAC,GAAG,IAAI;;EAEZ;EACA,KAAK,IAAIC,MAAM,IAAIC,IAAI,EAAE;IACvB,IAAI,OAAOA,IAAI,CAACD,MAAM,CAAC,KAAK,UAAU,EAAE;MACtCC,IAAI,CAACD,MAAM,CAAC,GAAGC,IAAI,CAACD,MAAM,CAAC,CAACE,IAAI,CAACH,CAAC,CAAC;IACrC;EACF;;EAEA;EACAE,IAAI,CAACE,UAAU,CAACJ,CAAC,EAAEE,IAAI,CAACG,eAAe,EAAE,CAAC;EAC1CH,IAAI,CAACI,eAAe,CAACN,CAAC,CAAC;;EAEvB;EACAE,IAAI,CAACK,mBAAmB,CAACP,CAAC,CAAC;AAC7B,CAAC;;AAED;AACA;AACA;AACA,IAAIE,IAAI,GAAGH,MAAM,CAACS,SAAS,CAACN,IAAI,GAAG,CAAC,CAAC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIO,OAAO,GAAE,SAAAA,CAASC,MAAM,EAAEC,QAAQ,EAAE;EACtC,IAAIX,CAAC,GAAG,IAAI;IACRY,KAAK,GAAGC,KAAK,CAACC,OAAO,CAACH,QAAQ,CAAC,GAAGA,QAAQ,GAAGA,QAAQ,CAACI,KAAK,CAAC,GAAG,CAAC;IAChEC,IAAI,GAAGJ,KAAK,CAAC,CAAC,CAAC;IACfK,KAAK,GAAGP,MAAM,CAACM,IAAI,CAAC;EACxB,IAAIJ,KAAK,CAACM,MAAM,IAAI,CAAC,EAAE;IACrB,OAAOD,KAAK;EACd;EACA;EACA,IAAIA,KAAK,KAAK,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC/C,OAAOE,SAAS;EAClB;EACA,OAAOV,OAAO,CAACQ,KAAK,EAAEL,KAAK,CAACQ,KAAK,CAAC,CAAC,CAAC,CAAC;AACvC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACArB,MAAM,CAACS,SAAS,CAACa,GAAG,GAAG,UAASV,QAAQ,EAAE;EACxC,IAAGA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAKQ,SAAS,EAAC;IAC7C,MAAM,IAAIG,KAAK,CAAC,oDAAoD,CAAC;EACvE;;EAEA;EACA,IAAIzB,eAAe,EAAE;IACnB,IAAI,CAACK,IAAI,CAACqB,SAAS,CAAC,wBAAwB,EAAE,KAAK,CAAC,EAAE;MACpDrB,IAAI,CAACsB,aAAa,CAACC,MAAM,CAAC;IAC5B;IACA5B,eAAe,GAAG,KAAK;EACzB;EACA,IAAIG,CAAC,GAAG,IAAI;IACRiB,KAAK,GAAGR,OAAO,CAACT,CAAC,EAAEW,QAAQ,CAAC;;EAEhC;EACA,IAAIM,KAAK,KAAKE,SAAS,EAAE;IACvB,MAAM,IAAIG,KAAK,CAAC,0BAA0B,GAAGX,QAAQ,GAAG,kBAAkB,CAAC;EAC7E;;EAEA;EACA,OAAOM,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlB,MAAM,CAACS,SAAS,CAACkB,GAAG,GAAG,UAASf,QAAQ,EAAE;EACxC;EACA,IAAGA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAKQ,SAAS,EAAC;IAC7C,OAAO,KAAK;EACd;EACA,IAAInB,CAAC,GAAG,IAAI;EACZ,OAAQS,OAAO,CAACT,CAAC,EAAEW,QAAQ,CAAC,KAAKQ,SAAS;AAC5C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAjB,IAAI,CAACyB,iBAAiB,GAAG,UAAUC,UAAU,EAAEC,iBAAiB,EAAE;EAEhE;EACA,IAAI7B,CAAC,GAAG,IAAI;IACV8B,YAAY,GAAG5B,IAAI,CAAC6B,SAAS,CAACF,iBAAiB,CAAC;;EAElD;EACA,IAAIjC,aAAa,CAACsB,MAAM,KAAK,CAAC,IAAItB,aAAa,CAAC,CAAC,CAAC,CAACoB,IAAI,KAAK,iBAAiB,EAAE;IAC7EpB,aAAa,CAACoC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE;MACzBhB,IAAI,EAAE,iBAAiB;MACvBiB,MAAM,EAAE,CAAC;IACX,CAAC,CAAC;EACJ;EACA/B,IAAI,CAACgC,OAAO,CAACtC,aAAa,CAAC,CAAC,CAAC,CAACqC,MAAM,EAAEL,UAAU,CAACb,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;EAChEb,IAAI,CAACE,UAAU,CAACK,OAAO,CAACb,aAAa,CAAC,CAAC,CAAC,CAACqC,MAAM,EAAEL,UAAU,CAAC,EAAEC,iBAAiB,CAAC;;EAEhF;EACA3B,IAAI,CAACgC,OAAO,CAAClC,CAAC,EAAE4B,UAAU,CAACb,KAAK,CAAC,GAAG,CAAC,EAAEN,OAAO,CAACT,CAAC,EAAE4B,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;;EAEpE;EACA1B,IAAI,CAACE,UAAU,CAAC0B,YAAY,EAAErB,OAAO,CAACT,CAAC,EAAE4B,UAAU,CAAC,CAAC;;EAErD;EACA1B,IAAI,CAACE,UAAU,CAACK,OAAO,CAACT,CAAC,EAAE4B,UAAU,CAAC,EAAEE,YAAY,CAAC;;EAErD;EACA;EACA;EACA,IAAI,CAAC5B,IAAI,CAACqB,SAAS,CAAC,wBAAwB,EAAE,KAAK,CAAC,EAAE;IACpD1B,eAAe,GAAG,IAAI;EACxB;;EAEA;EACA,OAAOK,IAAI,CAACI,eAAe,CAACG,OAAO,CAACT,CAAC,EAAE4B,UAAU,CAAC,CAAC;AACrD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA1B,IAAI,CAACiC,UAAU,GAAG,UAASzB,MAAM,EAAEC,QAAQ,EAAEM,KAAK,EAAE;EAElD;EACA,IAAI,OAAOA,KAAK,KAAK,WAAW,EAAE;IAChCmB,MAAM,CAACC,cAAc,CAAC3B,MAAM,EAAEC,QAAQ,EAAE;MACtC2B,UAAU,EAAG;IACf,CAAC,CAAC;EACJ;EACA;EAAA,KACK;IACHF,MAAM,CAACC,cAAc,CAAC3B,MAAM,EAAEC,QAAQ,EAAE;MACtCM,KAAK,EAAQA,KAAK;MAClBqB,UAAU,EAAG;IACf,CAAC,CAAC;EACJ;EAEA,OAAO5B,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAR,IAAI,CAACsB,aAAa,GAAG,UAASd,MAAM,EAAEC,QAAQ,EAAEM,KAAK,EAAE;EACrD,IAAIsB,MAAM,CAACC,QAAQ,CAAC9B,MAAM,CAAC,EAAE;IAC3B,OAAOA,MAAM;EACf;EACA,IAAI+B,UAAU,GAAG,IAAI;;EAErB;EACA,IAAI,OAAO9B,QAAQ,KAAK,QAAQ,EAAE;IAChC,OAAOyB,MAAM,CAACC,cAAc,CAAC3B,MAAM,EAAEC,QAAQ,EAAE;MAC7CM,KAAK,EAAI,OAAOA,KAAK,KAAK,WAAW,GAAIP,MAAM,CAACC,QAAQ,CAAC,GAAGM,KAAK;MACjEyB,QAAQ,EAAG,KAAK;MAChBC,YAAY,EAAE;IAChB,CAAC,CAAC;EACJ;;EAEA;EACA,IAAI9B,KAAK,CAACC,OAAO,CAACH,QAAQ,CAAC,EAAE;IAC3B8B,UAAU,GAAG9B,QAAQ;EACvB,CAAC,MACI;IACH8B,UAAU,GAAGL,MAAM,CAACQ,IAAI,CAAClC,MAAM,CAAC;EAClC;;EAEA;EACA,KAAK,IAAImC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,UAAU,CAACvB,MAAM,EAAE2B,CAAC,EAAE,EAAE;IAC1C,IAAIC,YAAY,GAAGL,UAAU,CAACI,CAAC,CAAC;MAC5B5B,KAAK,GAAGP,MAAM,CAACoC,YAAY,CAAC;IAEhC,IAAI7B,KAAK,YAAYlC,SAAS,EAAE;MAC9BqD,MAAM,CAACC,cAAc,CAAC3B,MAAM,EAAEoC,YAAY,EAAE;QAC1C7B,KAAK,EAAEA,KAAK,CAAC8B,OAAO,EAAE;QACtBL,QAAQ,EAAE,KAAK;QACfC,YAAY,EAAE;MAChB,CAAC,CAAC;IACJ,CAAC,MAAM,IAAI9B,KAAK,CAACC,OAAO,CAACG,KAAK,CAAC,EAAE;MAC/B;MACAA,KAAK,CAAC+B,OAAO,CAAC,CAACC,IAAI,EAAEC,KAAK,KAAK;QAAE,IAAIhD,IAAI,CAACiD,QAAQ,CAACF,IAAI,CAAC,IAAIpC,KAAK,CAACC,OAAO,CAACmC,IAAI,CAAC,EAAE/C,IAAI,CAACsB,aAAa,CAACyB,IAAI,CAAC;MAAC,CAAC,CAAC;MAE5Gb,MAAM,CAACC,cAAc,CAAC3B,MAAM,EAAEoC,YAAY,EAAE;QAC1C7B,KAAK,EAAEmB,MAAM,CAACgB,MAAM,CAACnC,KAAK;MAC5B,CAAC,CAAC;IACJ,CAAC,MAAM;MACL;MACA,IAAIf,IAAI,CAACiD,QAAQ,CAAClC,KAAK,CAAC,EAAE;QACxB;QACA;QACAA,KAAK,GAAG,IAAIoC,KAAK,CAACnD,IAAI,CAACsB,aAAa,CAACP,KAAK,CAAC,EAAE;UAC3CqC,GAAGA,CAAEC,MAAM,EAAEvC,IAAI,EAAE;YACjB,MAAMwC,OAAO,GAAIC,OAAO,CAAC/B,GAAG,CAAC6B,MAAM,EAAEvC,IAAI,CAAC,GAAG,QAAQ,GAAG,KAAM;YAC9D;YACA,MAAMM,KAAK,CAAE,WAAUkC,OAAQ,qCAAoCxC,IAAK,8EAA6E,CAAC;UACxJ;QACF,CAAC,CAAC;MACJ;MAEAoB,MAAM,CAACC,cAAc,CAAC3B,MAAM,EAAEoC,YAAY,EAAE;QAC1C7B,KAAK,EAAEA,KAAK;QACZyB,QAAQ,EAAG,KAAK;QAChBC,YAAY,EAAE;MAChB,CAAC,CAAC;;MAEF;MACA;MACAP,MAAM,CAACsB,iBAAiB,CAAChD,MAAM,CAACoC,YAAY,CAAC,CAAC;IAChD;EACF;EAEA,OAAOpC,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAR,IAAI,CAACyD,gBAAgB,GAAG,YAAW;EACjC,IAAI3D,CAAC,GAAG,IAAI;EACZ,OAAOJ,aAAa,CAACwB,KAAK,CAAC,CAAC,CAAC;AAC/B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlB,IAAI,CAAC0D,SAAS,GAAG,UAASC,OAAO,EAAEC,UAAU,EAAEC,YAAY,EAAE;EAC3D,IAAIF,OAAO,KAAK1C,SAAS,IAAI0C,OAAO,CAACC,UAAU,CAAC,KAAK3C,SAAS,EAAC;IAC7D,OAAO0C,OAAO,CAACC,UAAU,CAAC;EAC5B,CAAC,MAAM;IACL,OAAOC,YAAY;EACrB;AACF,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7D,IAAI,CAACG,eAAe,GAAG,UAAS2D,SAAS,EAAEH,OAAO,EAAE;EAElD;EACA,IAAI7D,CAAC,GAAG,IAAI;IACRyB,MAAM,GAAG,CAAC,CAAC;;EAEf;EACA,IAAIwC,kBAAkB,GAAG,CAAC,iBAAiB,EAAE,UAAU,CAAC;;EAExD;EACA,KAAK,MAAMC,iBAAiB,IAAID,kBAAkB,EAAE;IAClD3E,QAAQ,GAAGY,IAAI,CAACqB,SAAS,CAAC2C,iBAAiB,CAAC;IAC5C,IAAI,CAAC,CAAC5E,QAAQ,EAAE;MACdG,iBAAiB,GAAGyE,iBAAiB;MACrC;IACF;EACF;;EAEA;EACA,IAAI,CAAC5E,QAAQ,EAAE;IACbA,QAAQ,GAAG,aAAa;EAC1B;EAEA2E,kBAAkB,CAACjB,OAAO,CAACkB,iBAAiB,IAAI;IAC9CvE,GAAG,CAACuE,iBAAiB,CAAC,GAAG5E,QAAQ;EACnC,CAAC,CAAC;;EAEF;EACAA,QAAQ,GAAGA,QAAQ,CAACyB,KAAK,CAAC,GAAG,CAAC;EAE9B,IAAIoD,GAAG,GAAGH,SAAS,IAAI9D,IAAI,CAACqB,SAAS,CAAC,iBAAiB,EAAErC,IAAI,CAACkF,IAAI,CAAEC,OAAO,CAACC,GAAG,EAAE,EAAE,QAAQ,CAAC,CAAE;EAC9FH,GAAG,GAAGI,eAAe,CAACJ,GAAG,CAAC;EAE1B5E,YAAY,GAAGW,IAAI,CAACqB,SAAS,CAAC,mBAAmB,CAAC;EAClD/B,oBAAoB,GAAGU,IAAI,CAACqB,SAAS,CAAC,sBAAsB,CAAC;;EAE7D;EACA,IAAIiD,eAAe,GAAGtE,IAAI,CAACqB,SAAS,CAAC,0BAA0B,EAAErC,IAAI,CAACkF,IAAI,CAACD,GAAG,EAAG,cAAc,CAAC,CAAE;EAElGzE,kBAAkB,GAAGQ,IAAI,CAACqB,SAAS,CAAC,oBAAoB,CAAC;EACzD,IAAI7B,kBAAkB,EAAE;IACtB,IAAI;MACF,IAAI+E,YAAY,GAAGvF,IAAI,CAACwF,UAAU,CAAChF,kBAAkB,CAAC,GAClDA,kBAAkB,GAClBR,IAAI,CAACkF,IAAI,CAACD,GAAG,EAAEzE,kBAAkB,CAAC;MACtCV,MAAM,GAAGF,OAAO,CAAC2F,YAAY,CAAC;IAChC,CAAC,CACD,OAAOE,CAAC,EAAE;MACRC,OAAO,CAACC,IAAI,CAAC,oCAAoC,GAAGnF,kBAAkB,CAAC;MACvEkF,OAAO,CAACE,GAAG,CAACH,CAAC,CAAC;IAChB;EACF;EAEA,IAAII,IAAI,GAAG7E,IAAI,CAACqB,SAAS,CAAC,MAAM,CAAC;EACjC,IAAIyD,QAAQ,GAAG9E,IAAI,CAACqB,SAAS,CAAC,UAAU,CAAC;;EAEzC;EACA;EACA,IAAI;IACF,IAAI0D,QAAQ,GAAGF,IAAI,IAAIC,QAAQ;IAE/B,IAAI,CAACC,QAAQ,EAAE;MACX,IAAIC,EAAE,GAAGpG,OAAO,CAAC,IAAI,CAAC;MACtBmG,QAAQ,GAAGC,EAAE,CAACC,QAAQ,EAAE;IAC5B;EACF,CAAC,CAAC,OAAOR,CAAC,EAAE;IACVM,QAAQ,GAAG,EAAE;EACf;;EAEA;EACAtF,GAAG,CAACqF,QAAQ,GAAGC,QAAQ;;EAEvB;EACA,IAAIG,SAAS,GAAG,CAAC,SAAS,CAAC,CAACC,MAAM,CAAC/F,QAAQ,CAAC;;EAE5C;EACA,IAAI2F,QAAQ,EAAE;IACZ,IAAIK,WAAW,GAAGL,QAAQ,CAAClE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAExCzB,QAAQ,CAAC0D,OAAO,CAAC,UAASrD,GAAG,EAAE;MAC7B;MACAyF,SAAS,CAACG,IAAI,CAACD,WAAW,EAAEA,WAAW,GAAG,GAAG,GAAG3F,GAAG,CAAC;;MAEpD;MACA,IAAIsF,QAAQ,KAAKK,WAAW,EAAE;QAC5BF,SAAS,CAACG,IAAI,CAACN,QAAQ,EAAEA,QAAQ,GAAG,GAAG,GAAGtF,GAAG,CAAC;MAChD;IACF,CAAC,CAAC;EACJ;EAEAL,QAAQ,CAAC0D,OAAO,CAAC,UAASrD,GAAG,EAAE;IAC7ByF,SAAS,CAACG,IAAI,CAAC,OAAO,EAAE,QAAQ,GAAG5F,GAAG,CAAC;EACzC,CAAC,CAAC;EAEF,IAAI6F,YAAY,GAAG,CAAC,CAAC;EACrB,IAAIC,eAAe,GAAG,CAAC;EACvB,IAAIC,QAAQ,GAAG1G,MAAM,CAAC2G,aAAa,EAAE;EACrCP,SAAS,CAACpC,OAAO,CAAC,UAAS4C,QAAQ,EAAE;IACnCF,QAAQ,CAAC1C,OAAO,CAAC,UAAS6C,OAAO,EAAE;MACjCL,YAAY,CAACI,QAAQ,GAAG,GAAG,GAAGC,OAAO,CAAC,GAAGJ,eAAe,EAAE;MAC1D,IAAIlG,YAAY,EAAE;QAChBiG,YAAY,CAACI,QAAQ,GAAG,GAAG,GAAGrG,YAAY,GAAG,GAAG,GAAGsG,OAAO,CAAC,GAAGJ,eAAe,EAAE;MACjF;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;EAEF,IAAIK,YAAY,GAAG5F,IAAI,CAAC6F,mBAAmB,CAAC5B,GAAG,EAAEqB,YAAY,CAAC;EAC9DM,YAAY,CAAC9C,OAAO,CAAC,UAASgD,YAAY,EAAE;IAC1C,IAAIC,SAAS,GAAG/F,IAAI,CAACgG,SAAS,CAACF,YAAY,EAAEnC,OAAO,CAAC;IACrD,IAAIoC,SAAS,EAAE;MACb/F,IAAI,CAACE,UAAU,CAACqB,MAAM,EAAEwE,SAAS,CAAC;IACpC;EACF,CAAC,CAAC;;EAEF;EACA;EACA,IAAI,CAACjC,SAAS,EAAE;IACd,IAAImC,SAAS,GAAG,CAAC,CAAC;IAElB9G,UAAU,GAAG8E,GAAG;IAEhB,IAAIE,OAAO,CAAC1E,GAAG,CAACyG,WAAW,EAAE;MAC3B,IAAI;QACFD,SAAS,GAAGE,IAAI,CAACC,KAAK,CAACjC,OAAO,CAAC1E,GAAG,CAACyG,WAAW,CAAC;MACjD,CAAC,CAAC,OAAMzB,CAAC,EAAE;QACTC,OAAO,CAAC2B,KAAK,CAAC,yDAAyD,CAAC;MAC1E;MACArG,IAAI,CAACE,UAAU,CAACqB,MAAM,EAAE0E,SAAS,CAAC;MAClC,IAAIK,iBAAiB,GAAGtG,IAAI,CAAC0D,SAAS,CAACC,OAAO,EAAC,mBAAmB,EAAE,KAAK,CAAC;MAC1E,IAAI,CAAC2C,iBAAiB,EAAC;QACrB5G,aAAa,CAAC2F,IAAI,CAAC;UACjBvE,IAAI,EAAE,cAAc;UACpBiB,MAAM,EAAEkE;QACV,CAAC,CAAC;MACJ;IACF;;IAEA;IACA,IAAIM,aAAa,GAAGvG,IAAI,CAACwG,aAAa,CAAC,aAAa,CAAC;IACrD,IAAID,aAAa,EAAE;MACjB,IAAI;QACFA,aAAa,GAAGJ,IAAI,CAACC,KAAK,CAACG,aAAa,CAAC;MAC3C,CAAC,CAAC,OAAM9B,CAAC,EAAE;QACTC,OAAO,CAAC2B,KAAK,CAAC,kEAAkE,CAAC;MACnF;MACArG,IAAI,CAACE,UAAU,CAACqB,MAAM,EAAEgF,aAAa,CAAC;MACtC,IAAID,iBAAiB,GAAGtG,IAAI,CAAC0D,SAAS,CAACC,OAAO,EAAC,mBAAmB,EAAE,KAAK,CAAC;MAC1E,IAAI,CAAC2C,iBAAiB,EAAC;QACrB5G,aAAa,CAAC2F,IAAI,CAAC;UACjBvE,IAAI,EAAE,wBAAwB;UAC9BiB,MAAM,EAAEwE;QACV,CAAC,CAAC;MACJ;IACF;;IAEA;IACA9G,GAAG,CAAC,aAAa,CAAC,GAAG0G,IAAI,CAACM,SAAS,CAACzG,IAAI,CAACE,UAAU,CAAC+F,SAAS,EAAEM,aAAa,EAAE,CAAC,CAAC,CAAC,CAAC;EACpF;;EAEA;EACA,IAAIG,aAAa,GAAG1G,IAAI,CAAC2G,gBAAgB,CAAC1C,GAAG,EAAEuB,QAAQ,CAAC;EACxDxF,IAAI,CAACE,UAAU,CAACqB,MAAM,EAAEmF,aAAa,CAAC;;EAEtC;EACA,IAAIE,WAAW,GAAG5G,IAAI,CAACgG,SAAS,CAAC1B,eAAe,CAAC,IAAI,CAAC,CAAC;EACvDtE,IAAI,CAACE,UAAU,CAACqB,MAAM,EAAEqF,WAAW,CAAC;EAEpC5G,IAAI,CAAC6G,sBAAsB,CAACtF,MAAM,CAAC;;EAEnC;EACA,OAAOA,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAvB,IAAI,CAAC6F,mBAAmB,GAAG,UAASiB,UAAU,EAAExB,YAAY,EAAE;EAC5D,OAAOwB,UAAU,CAACjG,KAAK,CAAC7B,IAAI,CAAC+H,SAAS,CAAC,CACpCC,MAAM,CAAC,UAASC,KAAK,EAAEnD,SAAS,EAAE;IACjC,IAAIA,SAAS,EAAE;MACbA,SAAS,GAAGO,eAAe,CAACP,SAAS,CAAC;MACtC,IAAI;QACF7E,UAAU,CAACiI,WAAW,CAACpD,SAAS,CAAC,CAAChB,OAAO,CAAC,UAASqE,IAAI,EAAE;UACvD,IAAI7B,YAAY,CAAC6B,IAAI,CAAC,EAAE;YACtBF,KAAK,CAAC5B,IAAI,CAAC,CAACC,YAAY,CAAC6B,IAAI,CAAC,EAAEnI,IAAI,CAACkF,IAAI,CAACJ,SAAS,EAAEqD,IAAI,CAAC,CAAC,CAAC;UAC9D;QACF,CAAC,CAAC;MACJ,CAAC,CACD,OAAM1C,CAAC,EAAE,CAAC;MACV,OAAOwC,KAAK;IACd;EACF,CAAC,EAAE,EAAE,CAAC,CACLG,IAAI,CAAC,UAASC,CAAC,EAAEC,CAAC,EAAE;IAAE,OAAOD,CAAC,CAAC,CAAC,CAAC,GAAGC,CAAC,CAAC,CAAC,CAAC;EAAE,CAAC,CAAC,CAC5CC,GAAG,CAAC,UAASJ,IAAI,EAAE;IAAE,OAAOA,IAAI,CAAC,CAAC,CAAC;EAAE,CAAC,CAAC;AAC5C,CAAC;;AAED;AACAnH,IAAI,CAAC6G,sBAAsB,GAAG,UAAUtF,MAAM,EAAE;EAC9C,IAAIiG,QAAQ,GAAG,EAAE;EAEjB,SAASC,QAAQA,CAAEC,IAAI,EAAE;IAEvB;IACA,IAAIC,WAAW,GAAG,EAAE;;IAEpB;IACA,KAAK,IAAIlH,QAAQ,IAAIiH,IAAI,EAAE;MACzB,IAAIxF,MAAM,CAAC0F,cAAc,CAACC,IAAI,CAACH,IAAI,EAAEjH,QAAQ,CAAC,IAAIiH,IAAI,CAACjH,QAAQ,CAAC,IAAI,IAAI,EAAE;QACxEkH,WAAW,CAACtC,IAAI,CAAC5E,QAAQ,CAAC;MAC5B;IACF;;IAEA;IACAkH,WAAW,CAACP,IAAI,EAAE,CAACtE,OAAO,CAAC,UAAUrC,QAAQ,EAAE;MAC7C,IAAIiH,IAAI,CAACjH,QAAQ,CAAC,CAACqH,WAAW,KAAK5F,MAAM,EAAE;QACzCuF,QAAQ,CAACC,IAAI,CAACjH,QAAQ,CAAC,CAAC;MAC1B,CAAC,MAAM,IAAIiH,IAAI,CAACjH,QAAQ,CAAC,CAACqH,WAAW,KAAKnH,KAAK,EAAE;QAC/C,KAAK,IAAIgC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+E,IAAI,CAACjH,QAAQ,CAAC,CAACO,MAAM,EAAE2B,CAAC,EAAE,EAAE;UAC9C,IAAI+E,IAAI,CAACjH,QAAQ,CAAC,CAACkC,CAAC,CAAC,YAAYhE,cAAc,EAAE;YAC/C6I,QAAQ,CAACnC,IAAI,CAACqC,IAAI,CAACjH,QAAQ,CAAC,CAACkC,CAAC,CAAC,CAACoF,OAAO,CAACxG,MAAM,EAAEmG,IAAI,CAACjH,QAAQ,CAAC,EAAEkC,CAAC,CAAC,CAAC;UACrE,CAAC,MACI;YACH8E,QAAQ,CAACC,IAAI,CAACjH,QAAQ,CAAC,CAACkC,CAAC,CAAC,CAAC;UAC7B;QACF;MACF,CAAC,MAAM;QACL,IAAI+E,IAAI,CAACjH,QAAQ,CAAC,YAAY9B,cAAc,EAAE;UAC5C6I,QAAQ,CAACnC,IAAI,CAACqC,IAAI,CAACjH,QAAQ,CAAC,CAACsH,OAAO,CAACxG,MAAM,EAAEmG,IAAI,EAAEjH,QAAQ,CAAC,CAAC;QAC/D;QACA;MACF;IACF,CAAC,CAAC;EACJ;;EAEAgH,QAAQ,CAAClG,MAAM,CAAC;EAEhBiG,QAAQ,CAAC1E,OAAO,CAAC,UAAUkF,KAAK,EAAE;IAAEA,KAAK,CAACnF,OAAO,EAAE;EAAE,CAAC,CAAC;AACzD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7C,IAAI,CAACgG,SAAS,GAAG,UAASF,YAAY,EAAEnC,OAAO,EAAE;EAC/C,IAAI7D,CAAC,GAAG,IAAI;IAAG;IACXmI,YAAY,GAAG,IAAI;IACnBC,WAAW,GAAG,IAAI;IAClBC,IAAI,GAAG,IAAI;;EAEf;EACA;;EAEA,IAAI;IACF;IACAD,WAAW,GAAGjJ,UAAU,CAACmJ,YAAY,CAACtC,YAAY,EAAE,OAAO,CAAC;IAC5DoC,WAAW,GAAGA,WAAW,CAACG,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC;EAClD,CAAC,CACD,OAAOC,EAAE,EAAE;IACT,IAAIA,EAAE,CAACC,IAAI,KAAK,QAAQ,EAAE;MACxB,MAAM,IAAInH,KAAK,CAAC,cAAc,GAAG0E,YAAY,GAAG,kCAAkC,GAACwC,EAAE,CAACC,IAAI,GACvE,sBAAsB,GAACD,EAAE,CAAChF,OAAO,CAAC;IACvD;IACA,OAAO,IAAI,CAAC,CAAE;EAChB;;EAEA;EACA,IAAI;IAEF;IACA,IAAIhE,oBAAoB,EAAE;MACxB,IAAIM,iBAAiB,CAAC4I,IAAI,CAACN,WAAW,CAAC,EAAE;QACvCxD,OAAO,CAAC2B,KAAK,CAAC,WAAW,GAAGP,YAAY,GAAG,iEAAiE,CAAC;QAC7G,OAAO,IAAI;MACb;IACF;IAEAmC,YAAY,GAAGnJ,MAAM,CAACsH,KAAK,CAACN,YAAY,EAAEoC,WAAW,CAAC;EACxD,CAAC,CACD,OAAOO,EAAE,EAAE;IACT,IAAI7I,iBAAiB,CAAC4I,IAAI,CAACN,WAAW,CAAC,EAAE;MACvCxD,OAAO,CAAC2B,KAAK,CAAC,SAAS,GAAGP,YAAY,GAAG,2DAA2D,CAAC;IACvG;IACA,MAAM,IAAI1E,KAAK,CAAC,6BAA6B,GAAG0E,YAAY,GAAG,KAAK,GAAG2C,EAAE,CAAC;EAC5E;;EAEA;EACA,IAAInC,iBAAiB,GAAGtG,IAAI,CAAC0D,SAAS,CAACC,OAAO,EAAC,mBAAmB,EAAE,KAAK,CAAC;EAC1E,IAAI,OAAOsE,YAAY,KAAK,QAAQ,IAAI,CAAC3B,iBAAiB,EAAE;IAC1D5G,aAAa,CAAC2F,IAAI,CAAC;MACjBvE,IAAI,EAAEgF,YAAY;MAClB4C,QAAQ,EAAER,WAAW;MACrBnG,MAAM,EAAEkG;IACV,CAAC,CAAC;EACJ;EAEA,OAAOA,YAAY;AACrB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAjI,IAAI,CAAC2I,WAAW,GAAG,UAAUC,OAAO,EAAEC,MAAM,EAAE;EAC5C,IAAIC,MAAM,GAAGhK,MAAM,CAACiK,SAAS,CAACF,MAAM,CAAC;EACrC,IAAI,OAAOC,MAAM,KAAK,UAAU,EAAE;IAChC,OAAOA,MAAM,CAAC,IAAI,EAAEF,OAAO,CAAC;EAC9B;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA5I,IAAI,CAACI,eAAe,GAAG,UAAS4I,QAAQ,EAAEC,KAAK,EAAE;EAC/C,IAAID,QAAQ,YAAYnK,SAAS,EAAE;IACjC,OAAOmK,QAAQ;EACjB;;EAEA;EACA,IAAIlJ,CAAC,GAAG,IAAI;EACZmJ,KAAK,GAAIA,KAAK,KAAK,IAAI,GAAG/J,mBAAmB,GAAG+J,KAAM;EACtD,IAAIA,KAAK,GAAG,CAAC,EAAE;IACb,OAAOD,QAAQ;EACjB;;EAEA;EACA;EACA,KAAK,IAAIjJ,MAAM,IAAIF,MAAM,CAACS,SAAS,EAAE;IACnC,IAAI,CAAC0I,QAAQ,CAACjJ,MAAM,CAAC,EAAE;MACrBC,IAAI,CAACiC,UAAU,CAAC+G,QAAQ,EAAEjJ,MAAM,EAAEF,MAAM,CAACS,SAAS,CAACP,MAAM,CAAC,CAAC;IAC7D;EACF;;EAEA;EACA,KAAK,IAAI2H,IAAI,IAAIsB,QAAQ,EAAE;IACzB,IAAIhJ,IAAI,CAACiD,QAAQ,CAAC+F,QAAQ,CAACtB,IAAI,CAAC,CAAC,EAAE;MACjC1H,IAAI,CAACI,eAAe,CAAC4I,QAAQ,CAACtB,IAAI,CAAC,EAAEuB,KAAK,GAAG,CAAC,CAAC;IACjD;EACF;;EAEA;EACA,OAAOD,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAhJ,IAAI,CAAC6B,SAAS,GAAG,SAASA,SAASA,CAACqH,MAAM,EAAED,KAAK,EAAEE,QAAQ,EAAE7I,SAAS,EAAE;EACtE;EACA;EACA,IAAI8I,UAAU,GAAG,EAAE;EACnB,IAAIC,WAAW,GAAG,EAAE;EAEpB,IAAIC,SAAS,GAAG,OAAOjH,MAAM,IAAI,WAAW;EAE5C,IAAI,OAAO8G,QAAQ,KAAK,WAAW,EACjCA,QAAQ,GAAG,IAAI;EAEjB,IAAI,OAAOF,KAAK,KAAK,WAAW,EAC9BA,KAAK,GAAG,EAAE;;EAEZ;EACA,SAASM,MAAMA,CAACL,MAAM,EAAED,KAAK,EAAE;IAC7B;IACA,IAAIC,MAAM,KAAK,IAAI,EACjB,OAAO,IAAI;IAEb,IAAID,KAAK,KAAK,CAAC,EACb,OAAOC,MAAM;IAEf,IAAIM,KAAK;IACT,IAAI,OAAON,MAAM,IAAI,QAAQ,EAAE;MAC7B,OAAOA,MAAM;IACf;IAEA,IAAInK,KAAK,CAAC6B,OAAO,CAACsI,MAAM,CAAC,EAAE;MACzBM,KAAK,GAAG,EAAE;IACZ,CAAC,MAAM,IAAIzK,KAAK,CAAC0K,QAAQ,CAACP,MAAM,CAAC,EAAE;MACjCM,KAAK,GAAG,IAAIE,MAAM,CAACR,MAAM,CAACS,MAAM,EAAE3J,IAAI,CAAC4J,cAAc,CAACV,MAAM,CAAC,CAAC;MAC9D,IAAIA,MAAM,CAACW,SAAS,EAAEL,KAAK,CAACK,SAAS,GAAGX,MAAM,CAACW,SAAS;IAC1D,CAAC,MAAM,IAAI9K,KAAK,CAAC+K,MAAM,CAACZ,MAAM,CAAC,EAAE;MAC/BM,KAAK,GAAG,IAAIO,IAAI,CAACb,MAAM,CAACc,OAAO,EAAE,CAAC;IACpC,CAAC,MAAM,IAAIV,SAAS,IAAIjH,MAAM,CAACC,QAAQ,CAAC4G,MAAM,CAAC,EAAE;MAC/CM,KAAK,GAAGnH,MAAM,CAAC4H,KAAK,CAACf,MAAM,CAAClI,MAAM,CAAC;MACnCkI,MAAM,CAACgB,IAAI,CAACV,KAAK,CAAC;MAClB,OAAOA,KAAK;IACd,CAAC,MAAM;MACL,IAAI,OAAOlJ,SAAS,KAAK,WAAW,EAAEkJ,KAAK,GAAGtH,MAAM,CAACiI,MAAM,CAACjI,MAAM,CAACkI,cAAc,CAAClB,MAAM,CAAC,CAAC,CAAC,KACtFM,KAAK,GAAGtH,MAAM,CAACiI,MAAM,CAAC7J,SAAS,CAAC;IACvC;IAEA,IAAI6I,QAAQ,EAAE;MACZ,IAAInG,KAAK,GAAGoG,UAAU,CAACiB,OAAO,CAACnB,MAAM,CAAC;MAEtC,IAAIlG,KAAK,IAAI,CAAC,CAAC,EAAE;QACf,OAAOqG,WAAW,CAACrG,KAAK,CAAC;MAC3B;MACAoG,UAAU,CAAC/D,IAAI,CAAC6D,MAAM,CAAC;MACvBG,WAAW,CAAChE,IAAI,CAACmE,KAAK,CAAC;IACzB;IAEA,KAAK,IAAI7G,CAAC,IAAIuG,MAAM,EAAE;MACpB,IAAIoB,cAAc,GAAIpI,MAAM,CAACqI,wBAAwB,CAACrB,MAAM,EAACvG,CAAC,CAAC;MAC/D,IAAI6H,SAAS,GAAKF,cAAc,KAAKrJ,SAAS,IAAMqJ,cAAc,CAACnJ,GAAG,KAAKF,SAAW;MAEtF,IAAIuJ,SAAS,EAAC;QACZtI,MAAM,CAACC,cAAc,CAACqH,KAAK,EAAC7G,CAAC,EAAC2H,cAAc,CAAC;MAC/C,CAAC,MAAM,IAAItK,IAAI,CAACyK,SAAS,CAACvB,MAAM,CAACvG,CAAC,CAAC,CAAC,EAAE;QACpC6G,KAAK,CAAC7G,CAAC,CAAC,GAAGuG,MAAM,CAACvG,CAAC,CAAC;MACtB,CAAC,MAAM;QACL6G,KAAK,CAAC7G,CAAC,CAAC,GAAG4G,MAAM,CAACL,MAAM,CAACvG,CAAC,CAAC,EAAEsG,KAAK,GAAG,CAAC,CAAC;MACzC;IACF;IAEA,OAAOO,KAAK;EACd;EAEA,OAAOD,MAAM,CAACL,MAAM,EAAED,KAAK,CAAC;AAC9B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAjJ,IAAI,CAACgC,OAAO,GAAG,UAAUxB,MAAM,EAAEkK,IAAI,EAAE3J,KAAK,EAAE;EAC5C,IAAI4J,OAAO,GAAG,IAAI;EAClB,IAAI5J,KAAK,KAAK,IAAI,IAAI2J,IAAI,CAAC1J,MAAM,KAAK,CAAC,EAAE;IACvC;EACF,CAAC,MACI,IAAI0J,IAAI,CAAC1J,MAAM,KAAK,CAAC,EAAE;IAAE;IAC5BR,MAAM,CAACkK,IAAI,CAACE,KAAK,EAAE,CAAC,GAAG7J,KAAK;EAC9B,CAAC,MACI;IACH4J,OAAO,GAAGD,IAAI,CAACE,KAAK,EAAE;IACtB,IAAI,CAAC1I,MAAM,CAAC0F,cAAc,CAACC,IAAI,CAACrH,MAAM,EAAEmK,OAAO,CAAC,EAAE;MAChDnK,MAAM,CAACmK,OAAO,CAAC,GAAG,CAAC,CAAC;IACtB;IACA3K,IAAI,CAACgC,OAAO,CAACxB,MAAM,CAACmK,OAAO,CAAC,EAAED,IAAI,EAAE3J,KAAK,CAAC;EAC5C;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAf,IAAI,CAAC6K,cAAc,GAAG,UAAUC,eAAe,EAAEC,SAAS,EAAE;EAC1D,IAAIC,MAAM,GAAG,CAAC,CAAC;EAEf,SAASC,eAAeA,CAAC1D,GAAG,EAAE2D,IAAI,EAAEC,MAAM,EAAE;IAC1C,KAAK,IAAIzD,IAAI,IAAIH,GAAG,EAAE;MACpB,IAAIxG,KAAK,GAAGwG,GAAG,CAACG,IAAI,CAAC;MACrB,IAAI,OAAO3G,KAAM,KAAK,QAAQ,EAAE;QAAE;QAChC,IAAImK,IAAI,CAACnK,KAAK,CAAC,KAAKE,SAAS,IAAIiK,IAAI,CAACnK,KAAK,CAAC,KAAK,EAAE,EAAE;UAAE;UACrDf,IAAI,CAACgC,OAAO,CAACgJ,MAAM,EAAEG,MAAM,CAAChG,MAAM,CAACuC,IAAI,CAAC,EAAEwD,IAAI,CAACnK,KAAK,CAAC,CAAC;QACxD;MACF,CAAC,MACI,IAAIf,IAAI,CAACiD,QAAQ,CAAClC,KAAK,CAAC,EAAE;QAAE;QAC/B,IAAI,QAAQ,IAAIA,KAAK,IAAI,UAAU,IAAIA,KAAK,IAAImK,IAAI,CAACnK,KAAK,CAACqK,MAAM,CAAC,KAAKnK,SAAS,IAAIiK,IAAI,CAACnK,KAAK,CAACqK,MAAM,CAAC,KAAK,EAAE,EAAE;UAC7G,IAAI;YACF,IAAIC,WAAW,GAAGrL,IAAI,CAAC2I,WAAW,CAACuC,IAAI,CAACnK,KAAK,CAACqK,MAAM,CAAC,EAAErK,KAAK,CAACuK,QAAQ,CAAC;UACxE,CAAC,CAAC,OAAMC,GAAG,EAAE;YACXA,GAAG,CAACjI,OAAO,GAAG,2BAA2B,GAAGvC,KAAK,CAACqK,MAAM,GAAG,IAAI,GAAGG,GAAG,CAACjI,OAAO;YAC7E,MAAMiI,GAAG;UACX;UACAvL,IAAI,CAACgC,OAAO,CAACgJ,MAAM,EAAEG,MAAM,CAAChG,MAAM,CAACuC,IAAI,CAAC,EAAE2D,WAAW,CAAC;QACxD,CAAC,MAAM;UACLJ,eAAe,CAAClK,KAAK,EAAEmK,IAAI,EAAEC,MAAM,CAAChG,MAAM,CAACuC,IAAI,CAAC,CAAC;QACnD;MACF,CAAC,MACI;QACH8D,GAAG,GAAG,2CAA2C,GAAGL,MAAM,CAACjH,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,OAAOnD,KAAM;QAC3F,MAAMK,KAAK,CAACoK,GAAG,CAAC;MAClB;IACF;EACF;EAEAP,eAAe,CAACH,eAAe,EAAEC,SAAS,EAAE,EAAE,CAAC;EAC/C,OAAOC,MAAM;AAEf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAhL,IAAI,CAAC2G,gBAAgB,GAAG,UAAU7C,SAAS,EAAE0B,QAAQ,EAAE;EACrD,IAAIwF,MAAM,GAAG,CAAC,CAAC;EACf,IAAIzF,eAAe,GAAG,CAAC;EACvB,IAAID,YAAY,GAAG,CAAC,CAAC;EACrBE,QAAQ,CAAC1C,OAAO,CAAC,UAAU6C,OAAO,EAAE;IAClCL,YAAY,CAAC,8BAA8B,GAAG,GAAG,GAAGK,OAAO,CAAC,GAAGJ,eAAe,EAAE;EAClF,CAAC,CAAC;EACF,IAAIK,YAAY,GAAG5F,IAAI,CAAC6F,mBAAmB,CAAC/B,SAAS,EAAEwB,YAAY,CAAC;EACpEM,YAAY,CAAC9C,OAAO,CAAC,UAAUgD,YAAY,EAAE;IAC3C,IAAIC,SAAS,GAAG/F,IAAI,CAACgG,SAAS,CAACF,YAAY,CAAC;IAC5C,IAAIC,SAAS,EAAE;MACb,IAAI0F,wBAAwB,GAAGzL,IAAI,CAAC6K,cAAc,CAAC9E,SAAS,EAAE5B,OAAO,CAAC1E,GAAG,CAAC;MAC1EO,IAAI,CAACE,UAAU,CAAC8K,MAAM,EAAES,wBAAwB,CAAC;IACnD;EACF,CAAC,CAAC;EACF,OAAOT,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAhL,IAAI,CAAC0L,UAAU,GAAG,UAASC,OAAO,EAAEC,OAAO,EAAE3C,KAAK,EAAE;EAElD;EACA,IAAInJ,CAAC,GAAG,IAAI;EACZmJ,KAAK,GAAIA,KAAK,KAAK,IAAI,GAAG/J,mBAAmB,GAAG+J,KAAM;EACtD,IAAIA,KAAK,GAAG,CAAC,EAAE;IACb,OAAO,CAAC,CAAC;EACX;;EAEA;EACA,IAAI,CAAC0C,OAAO,IAAI,CAACC,OAAO,EAAE;IACxB,OAAO,KAAK;EACd;EACA,IAAID,OAAO,KAAKC,OAAO,EAAE;IACvB,OAAO,IAAI;EACb;EACA,IAAI,OAAOD,OAAQ,IAAI,QAAQ,IAAI,OAAOC,OAAQ,IAAI,QAAQ,EAAE;IAC9D,OAAO,KAAK;EACd;;EAEA;EACA;EACA;EACA,IAAI1J,MAAM,CAACQ,IAAI,CAACiJ,OAAO,CAAC,CAAC3K,MAAM,IAAIkB,MAAM,CAACQ,IAAI,CAACkJ,OAAO,CAAC,CAAC5K,MAAM,EAAE;IAC9D,OAAO,KAAK;EACd;;EAEA;EACA,KAAK,IAAI0G,IAAI,IAAIiE,OAAO,EAAE;IAExB;IACA,IAAIA,OAAO,CAACjE,IAAI,CAAC,IAAI,OAAOiE,OAAO,CAACjE,IAAI,CAAE,KAAK,QAAQ,EAAE;MACvD,IAAI,CAAC1H,IAAI,CAAC0L,UAAU,CAACC,OAAO,CAACjE,IAAI,CAAC,EAAEkE,OAAO,CAAClE,IAAI,CAAC,EAAEuB,KAAK,GAAG,CAAC,CAAC,EAAE;QAC7D,OAAO,KAAK;MACd;IACF,CAAC,MACI;MACH,IAAI0C,OAAO,CAACjE,IAAI,CAAC,KAAKkE,OAAO,CAAClE,IAAI,CAAC,EAAE;QACnC,OAAO,KAAK;MACd;IACF;EACF;;EAEA;EACA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA1H,IAAI,CAAC6L,QAAQ,GAAG,UAASF,OAAO,EAAEC,OAAO,EAAE3C,KAAK,EAAE;EAEhD;EACA,IAAInJ,CAAC,GAAG,IAAI;IAAEgM,IAAI,GAAG,CAAC,CAAC;EACvB7C,KAAK,GAAIA,KAAK,KAAK,IAAI,GAAG/J,mBAAmB,GAAG+J,KAAM;EACtD,IAAIA,KAAK,GAAG,CAAC,EAAE;IACb,OAAO,CAAC,CAAC;EACX;;EAEA;EACA;EACA,KAAK,IAAI8C,IAAI,IAAIH,OAAO,EAAE;IACxB,IAAII,MAAM,GAAGL,OAAO,CAACI,IAAI,CAAC;IAC1B,IAAIE,MAAM,GAAGL,OAAO,CAACG,IAAI,CAAC;IAC1B,IAAIC,MAAM,IAAIC,MAAM,IAAIjM,IAAI,CAACiD,QAAQ,CAACgJ,MAAM,CAAC,EAAE;MAC7C,IAAI,CAAEjM,IAAI,CAAC0L,UAAU,CAACM,MAAM,EAAEC,MAAM,CAAE,EAAE;QACtCH,IAAI,CAACC,IAAI,CAAC,GAAG/L,IAAI,CAAC6L,QAAQ,CAACG,MAAM,EAAEC,MAAM,EAAEhD,KAAK,GAAG,CAAC,CAAC;MACvD;IACF,CAAC,MACI,IAAItI,KAAK,CAACC,OAAO,CAACoL,MAAM,CAAC,IAAIrL,KAAK,CAACC,OAAO,CAACqL,MAAM,CAAC,EAAE;MACvD,IAAG,CAACjM,IAAI,CAAC0L,UAAU,CAACM,MAAM,EAAEC,MAAM,CAAC,EAAE;QACnCH,IAAI,CAACC,IAAI,CAAC,GAAGE,MAAM;MACrB;IACF,CAAC,MACI,IAAID,MAAM,KAAKC,MAAM,EAAC;MACzBH,IAAI,CAACC,IAAI,CAAC,GAAGE,MAAM;IACrB;EACF;;EAEA;EACA,OAAOH,IAAI;AAEb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA9L,IAAI,CAACE,UAAU,GAAG,UAASgM,SAAS,EAAE;EAEpC;EACA,IAAIpM,CAAC,GAAG,IAAI;EACZ,IAAIqM,KAAK,GAAGxL,KAAK,CAACL,SAAS,CAACY,KAAK,CAAC2G,IAAI,CAACuE,SAAS,EAAE,CAAC,CAAC;EACpD,IAAInD,KAAK,GAAGkD,KAAK,CAACE,GAAG,EAAE;EACvB,IAAI,OAAOpD,KAAM,IAAI,QAAQ,EAAE;IAC7BkD,KAAK,CAAC9G,IAAI,CAAC4D,KAAK,CAAC;IACjBA,KAAK,GAAG/J,mBAAmB;EAC7B;;EAEA;EACA,IAAI+J,KAAK,GAAG,CAAC,EAAE;IACb,OAAOiD,SAAS;EAClB;;EAEA;EACAC,KAAK,CAACrJ,OAAO,CAAC,UAASwJ,SAAS,EAAE;IAEhC;IACA,KAAK,IAAI5E,IAAI,IAAI4E,SAAS,EAAE;MAE1B;MACA,IAAIC,kBAAkB,GAAGD,SAAS,CAAC5E,IAAI,CAAC,YAAY/I,cAAc;MAClE,IAAI6N,cAAc,GAAGN,SAAS,CAACxE,IAAI,CAAC,YAAY/I,cAAc;MAE9D,IAAI4N,kBAAkB,IAAIrK,MAAM,CAAC0F,cAAc,CAACC,IAAI,CAACqE,SAAS,EAAExE,IAAI,CAAC,EAAE;QACrE4E,SAAS,CAAC5E,IAAI,CAAC,CAAC+E,SAAS,GAAGD,cAAc,GAAGN,SAAS,CAACxE,IAAI,CAAC,CAAC+E,SAAS,GAAGP,SAAS,CAACxE,IAAI,CAAC;MAC1F;MACA;MACA,IAAI4E,SAAS,CAAC5E,IAAI,CAAC,YAAYqC,IAAI,EAAE;QACnCmC,SAAS,CAACxE,IAAI,CAAC,GAAG4E,SAAS,CAAC5E,IAAI,CAAC;MACnC;MAAE,IAAI4E,SAAS,CAAC5E,IAAI,CAAC,YAAYgC,MAAM,EAAE;QACvCwC,SAAS,CAACxE,IAAI,CAAC,GAAG4E,SAAS,CAAC5E,IAAI,CAAC;MACnC,CAAC,MAAM,IAAI1H,IAAI,CAACiD,QAAQ,CAACiJ,SAAS,CAACxE,IAAI,CAAC,CAAC,IAAI1H,IAAI,CAACiD,QAAQ,CAACqJ,SAAS,CAAC5E,IAAI,CAAC,CAAC,IAAI,CAAC8E,cAAc,EAAE;QAC9FxM,IAAI,CAACE,UAAU,CAACgM,SAAS,CAACxE,IAAI,CAAC,EAAE4E,SAAS,CAAC5E,IAAI,CAAC,EAAEuB,KAAK,GAAG,CAAC,CAAC;MAC9D,CAAC,MACI,IAAIjJ,IAAI,CAACyK,SAAS,CAAC6B,SAAS,CAAC5E,IAAI,CAAC,CAAC,EAAE;QACxCwE,SAAS,CAACxE,IAAI,CAAC,GAAG4E,SAAS,CAAC5E,IAAI,CAAC;MACnC;MACA;MAAA,KACK,IAAI4E,SAAS,CAAC5E,IAAI,CAAC,IAAI,OAAO4E,SAAS,CAAC5E,IAAI,CAAC,KAAK,QAAQ,EAAE;QAC/DwE,SAAS,CAACxE,IAAI,CAAC,GAAG1H,IAAI,CAAC6B,SAAS,CAACyK,SAAS,CAAC5E,IAAI,CAAC,EAAEuB,KAAK,GAAE,CAAC,CAAC;MAC7D;;MAEA;MAAA,KACK,IAAI/G,MAAM,CAACqI,wBAAwB,CAACrI,MAAM,CAACoK,SAAS,CAAC,EAAE5E,IAAI,CAAC,EAAC;QAC9DxF,MAAM,CAACC,cAAc,CAAC+J,SAAS,EAAExE,IAAI,EAAExF,MAAM,CAACqI,wBAAwB,CAACrI,MAAM,CAACoK,SAAS,CAAC,EAAE5E,IAAI,CAAC,CAAC;MACpG,CAAC,MAAM;QACHwE,SAAS,CAACxE,IAAI,CAAC,GAAG4E,SAAS,CAAC5E,IAAI,CAAC;MACrC;IACF;EACF,CAAC,CAAC;;EAEF;EACA,OAAOwE,SAAS;AAElB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlM,IAAI,CAACiD,QAAQ,GAAG,UAASyJ,GAAG,EAAE;EAC5B,OAAQA,GAAG,KAAK,IAAI,IAAM,OAAOA,GAAG,KAAK,QAAS,IAAI,CAAE/L,KAAK,CAACC,OAAO,CAAC8L,GAAG,CAAE;AAC7E,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA1M,IAAI,CAACyK,SAAS,GAAG,UAASiC,GAAG,EAAE;EAC7B,OAAOxK,MAAM,CAAC5B,SAAS,CAACqM,QAAQ,CAAC9E,IAAI,CAAC6E,GAAG,CAAC,KAAK,kBAAkB;AACnE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA1M,IAAI,CAACqB,SAAS,GAAG,UAAUuL,SAAS,EAAE/I,YAAY,EAAE;EAClD,IAAI/D,CAAC,GAAG,IAAI;;EAEZ;EACA,IAAIiB,KAAK,GAAGf,IAAI,CAACwG,aAAa,CAACoG,SAAS,CAAC,IAAIzI,OAAO,CAAC1E,GAAG,CAACmN,SAAS,CAAC,IAAI/I,YAAY;EACnFpE,GAAG,CAACmN,SAAS,CAAC,GAAG7L,KAAK;EACtB,OAAOA,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAf,IAAI,CAACwG,aAAa,GAAG,UAAUqG,SAAS,EAAE;EACtC,IAAIC,WAAW,GAAG3I,OAAO,CAAC4I,IAAI,CAAC7L,KAAK,CAAC,CAAC,EAAEiD,OAAO,CAAC4I,IAAI,CAAC/L,MAAM,CAAC;IACxDgM,OAAO,GAAG,IAAI,GAAGH,SAAS,GAAG,GAAG;EAEpC,KAAK,IAAII,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGH,WAAW,CAAC9L,MAAM,EAAEiM,MAAM,EAAE,EAAE;IAC1D,IAAIH,WAAW,CAACG,MAAM,CAAC,CAAC5C,OAAO,CAAC2C,OAAO,CAAC,KAAK,CAAC,EAAE;MAC9C,OAAOF,WAAW,CAACG,MAAM,CAAC,CAACC,MAAM,CAACF,OAAO,CAAChM,MAAM,CAAC;IACnD;EACF;EAEA,OAAO,KAAK;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAhB,IAAI,CAACmN,MAAM,GAAG,UAAUC,OAAO,EAAE;EAC/B,OAAO3N,GAAG,CAAC2N,OAAO,CAAC;AACrB,CAAC;;AAID;AACA;AACA;AACA;AACA;AACA;AACApN,IAAI,CAAC4J,cAAc,GAAG,UAAUyD,EAAE,EAAE;EAClC,IAAIC,KAAK,GAAG,EAAE;EACdD,EAAE,CAACE,MAAM,KAAKD,KAAK,IAAI,GAAG,CAAC;EAC3BD,EAAE,CAACG,UAAU,KAAKF,KAAK,IAAI,GAAG,CAAC;EAC/BD,EAAE,CAACI,SAAS,KAAKH,KAAK,IAAI,GAAG,CAAC;EAC9B,OAAOA,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAtN,IAAI,CAACgJ,QAAQ,GAAG,UAASzH,MAAM,EAAE;EAC/B,OAAO4E,IAAI,CAACC,KAAK,CAACD,IAAI,CAACM,SAAS,CAAClF,MAAM,IAAI,IAAI,CAAC,CAAC;AACnD,CAAC;;AAED;AACAvB,IAAI,CAACK,mBAAmB,GAAG,UAAUkB,MAAM,EAAE;EAC3C,IAAImM,OAAO,GAAGnM,MAAM,CAACvB,IAAI,CAACyD,gBAAgB,EAAE;EAE5C,IAAIkK,eAAe,GAAGD,OAAO,CAACnG,GAAG,CAAC,UAAUqG,GAAG,EAAE;IAC/C,OAAO5O,IAAI,CAAC6O,QAAQ,CAACD,GAAG,CAAC9M,IAAI,CAAC;EAChC,CAAC,CAAC;EAEF1B,QAAQ,CAAC0D,OAAO,CAAC,UAASrD,GAAG,EAAE;IAC7B;IACA,IAAIqO,gBAAgB,GAAGH,eAAe,CAACI,IAAI,CAAC,UAAUC,QAAQ,EAAE;MAC5D,OAAOA,QAAQ,CAACC,KAAK,CAACxO,GAAG,CAAC;IAC9B,CAAC,CAAC;IACF;IACA,IAAIA,GAAG,IAAKA,GAAG,KAAK,aAAc,IAAI,CAACqO,gBAAgB,EAAE;MACvDI,YAAY,CAAC3O,iBAAiB,GAAC,aAAa,GAACE,GAAG,GAAC,mDAAmD,CAAC;IACvG;IACA;IACA,IAAKA,GAAG,KAAK,SAAS,IAAMA,GAAG,KAAK,OAAQ,EAAE;MAC5CyO,YAAY,CAAC3O,iBAAiB,GAAC,aAAa,GAACE,GAAG,GAAC,iBAAiB,CAAC;IACrE;EACF,CAAC,CAAC;;EAEF;EACA,IAAI0O,qBAAqB,GAAGR,eAAe,CAACI,IAAI,CAAC,UAAUC,QAAQ,EAAE;IACjE,OAAOA,QAAQ,CAACC,KAAK,CAAC5O,YAAY,CAAC;EACvC,CAAC,CAAC;EACF,IAAIA,YAAY,IAAI,CAAC8O,qBAAqB,EAAE;IAC1CD,YAAY,CAAC,8BAA8B,GAAC7O,YAAY,GAAC,iDAAiD,CAAC;EAC7G;EAEA,SAAS6O,YAAYA,CAAE1C,GAAG,EAAE;IAC1B,IAAI4C,QAAQ,GAAGjK,OAAO,CAAC1E,GAAG,CAAC4O,uBAAuB;IAClD,IAAIC,MAAM,GAAGF,QAAQ,GAAG,SAAS,GAAG,WAAW;IAC/C,IAAIG,MAAM,GAAG,iEAAiE;IAE9E7J,OAAO,CAAC2B,KAAK,CAACiI,MAAM,GAAC9C,GAAG,CAAC;IACzB9G,OAAO,CAAC2B,KAAK,CAACiI,MAAM,GAACC,MAAM,CAAC;;IAE5B;IACA,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,CAAClE,OAAO,CAAC+D,QAAQ,CAAC,IAAI,CAAC,EAAE;MACxC,MAAM,IAAIhN,KAAK,CAACkN,MAAM,GAAC9C,GAAG,GAAC,GAAG,GAAC+C,MAAM,CAAC;IACxC;EACF;AACF,CAAC;;AAED;AACA,SAASlK,eAAeA,CAAEP,SAAS,EAAE;EACnC,IAAIA,SAAS,CAACuG,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;IAChC,OAAOrL,IAAI,CAACkF,IAAI,CAACC,OAAO,CAACC,GAAG,EAAE,EAAEN,SAAS,CAAC;EAC5C;EAEA,OAAOA,SAAS;AAClB;;AAEA;AACA,IAAIvC,MAAM,GAAGiN,MAAM,CAACC,OAAO,GAAG,IAAI5O,MAAM,EAAE;;AAE1C;AACAG,IAAI,CAAC0O,aAAa,GAAG5P,MAAM,CAAC4P,aAAa;AACzC1O,IAAI,CAAC2O,iBAAiB,GAAG7P,MAAM,CAAC6P,iBAAiB;;AAEjD;AACA,IAAIC,YAAY,GAAG,CAAE5O,IAAI,CAACqB,SAAS,CAAC,4BAA4B,CAAE;AAClE,IAAIuN,YAAY,IAAI1M,MAAM,CAACQ,IAAI,CAACnB,MAAM,CAAC,CAACP,MAAM,KAAK,CAAC,EAAE;EACpD0D,OAAO,CAAC2B,KAAK,CAAC,8DAA8D,GAAElH,UAAU,CAAC;EACzFuF,OAAO,CAAC2B,KAAK,CAAC,qFAAqF,CAAC;AACtG"},"metadata":{},"sourceType":"script","externalDependencies":[]}